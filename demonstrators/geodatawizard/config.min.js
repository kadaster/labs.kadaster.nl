/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 76118:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(82530);
/* provided dependency */ var console = __webpack_require__(80292);
// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b

// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var _require = __webpack_require__(78619),
  _require$codes = _require.codes,
  ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,
  ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
var AssertionError = __webpack_require__(66979);
var _require2 = __webpack_require__(85663),
  inspect = _require2.inspect;
var _require$types = (__webpack_require__(85663).types),
  isPromise = _require$types.isPromise,
  isRegExp = _require$types.isRegExp;
var objectAssign = __webpack_require__(10293)();
var objectIs = __webpack_require__(25280)();
var RegExpPrototypeTest = __webpack_require__(97615)('RegExp.prototype.test');
var errorCache = new Map();
var isDeepEqual;
var isDeepStrictEqual;
var parseExpressionAt;
var findNodeAround;
var decoder;
function lazyLoadComparison() {
  var comparison = __webpack_require__(61667);
  isDeepEqual = comparison.isDeepEqual;
  isDeepStrictEqual = comparison.isDeepStrictEqual;
}

// Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex
var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
var meta = (/* unused pure expression or super */ null && (["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", '\\b', '', '', "\\u000b", '\\f', '', "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f"]));
var escapeFn = function escapeFn(str) {
  return meta[str.charCodeAt(0)];
};
var warned = false;

// The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;
var NO_EXCEPTION_SENTINEL = {};

// All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function innerFail(obj) {
  if (obj.message instanceof Error) throw obj.message;
  throw new AssertionError(obj);
}
function fail(actual, expected, message, operator, stackStartFn) {
  var argsLen = arguments.length;
  var internalMessage;
  if (argsLen === 0) {
    internalMessage = 'Failed';
  } else if (argsLen === 1) {
    message = actual;
    actual = undefined;
  } else {
    if (warned === false) {
      warned = true;
      var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
    }
    if (argsLen === 2) operator = '!=';
  }
  if (message instanceof Error) throw message;
  var errArgs = {
    actual: actual,
    expected: expected,
    operator: operator === undefined ? 'fail' : operator,
    stackStartFn: stackStartFn || fail
  };
  if (message !== undefined) {
    errArgs.message = message;
  }
  var err = new AssertionError(errArgs);
  if (internalMessage) {
    err.message = internalMessage;
    err.generatedMessage = true;
  }
  throw err;
}
assert.fail = fail;

// The AssertionError is defined in internal/error.
assert.AssertionError = AssertionError;
function innerOk(fn, argLen, value, message) {
  if (!value) {
    var generatedMessage = false;
    if (argLen === 0) {
      generatedMessage = true;
      message = 'No value argument passed to `assert.ok()`';
    } else if (message instanceof Error) {
      throw message;
    }
    var err = new AssertionError({
      actual: value,
      expected: true,
      message: message,
      operator: '==',
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
}

// Pure assertion tests whether a value is truthy, as determined
// by !!value.
function ok() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  innerOk.apply(void 0, [ok, args.length].concat(args));
}
assert.ok = ok;

// The equality assertion tests shallow, coercive equality with ==.
/* eslint-disable no-restricted-properties */
assert.equal = function equal(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  // eslint-disable-next-line eqeqeq
  if (actual != expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '==',
      stackStartFn: equal
    });
  }
};

// The non-equality assertion tests for whether two objects are not
// equal with !=.
assert.notEqual = function notEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  // eslint-disable-next-line eqeqeq
  if (actual == expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '!=',
      stackStartFn: notEqual
    });
  }
};

// The equivalence assertion tests a deep equality relation.
assert.deepEqual = function deepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (!isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepEqual',
      stackStartFn: deepEqual
    });
  }
};

// The non-equivalence assertion tests for any deep inequality.
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepEqual',
      stackStartFn: notDeepEqual
    });
  }
};
/* eslint-enable */

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (!isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepStrictEqual',
      stackStartFn: deepStrictEqual
    });
  }
};
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepStrictEqual',
      stackStartFn: notDeepStrictEqual
    });
  }
}
assert.strictEqual = function strictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (!objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'strictEqual',
      stackStartFn: strictEqual
    });
  }
};
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notStrictEqual',
      stackStartFn: notStrictEqual
    });
  }
};
var Comparison = /*#__PURE__*/_createClass(function Comparison(obj, keys, actual) {
  var _this = this;
  _classCallCheck(this, Comparison);
  keys.forEach(function (key) {
    if (key in obj) {
      if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && RegExpPrototypeTest(obj[key], actual[key])) {
        _this[key] = actual[key];
      } else {
        _this[key] = obj[key];
      }
    }
  });
});
function compareExceptionKey(actual, expected, key, message, keys, fn) {
  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
    if (!message) {
      // Create placeholder objects to create a nice output.
      var a = new Comparison(actual, keys);
      var b = new Comparison(expected, keys, actual);
      var err = new AssertionError({
        actual: a,
        expected: b,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.actual = actual;
      err.expected = expected;
      err.operator = fn.name;
      throw err;
    }
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: fn.name,
      stackStartFn: fn
    });
  }
}
function expectedException(actual, expected, msg, fn) {
  if (typeof expected !== 'function') {
    if (isRegExp(expected)) return RegExpPrototypeTest(expected, actual);
    // assert.doesNotThrow does not accept objects.
    if (arguments.length === 2) {
      throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);
    }

    // Handle primitives properly.
    if (_typeof(actual) !== 'object' || actual === null) {
      var err = new AssertionError({
        actual: actual,
        expected: expected,
        message: msg,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.operator = fn.name;
      throw err;
    }
    var keys = Object.keys(expected);
    // Special handle errors to make sure the name and the message are compared
    // as well.
    if (expected instanceof Error) {
      keys.push('name', 'message');
    } else if (keys.length === 0) {
      throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
    }
    if (isDeepEqual === undefined) lazyLoadComparison();
    keys.forEach(function (key) {
      if (typeof actual[key] === 'string' && isRegExp(expected[key]) && RegExpPrototypeTest(expected[key], actual[key])) {
        return;
      }
      compareExceptionKey(actual, expected, key, msg, keys, fn);
    });
    return true;
  }
  // Guard instanceof against arrow functions as they don't have a prototype.
  if (expected.prototype !== undefined && actual instanceof expected) {
    return true;
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function getActual(fn) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
  }
  try {
    fn();
  } catch (e) {
    return e;
  }
  return NO_EXCEPTION_SENTINEL;
}
function checkIsPromise(obj) {
  // Accept native ES6 promises and promises that are implemented in a similar
  // way. Do not accept thenables that use a function as `obj` and that have no
  // `catch` handler.

  // TODO: thenables are checked up until they have the correct methods,
  // but according to documentation, the `then` method should receive
  // the `fulfill` and `reject` arguments as well or it may be never resolved.

  return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
}
function waitForActual(promiseFn) {
  return Promise.resolve().then(function () {
    var resultPromise;
    if (typeof promiseFn === 'function') {
      // Return a rejected promise if `promiseFn` throws synchronously.
      resultPromise = promiseFn();
      // Fail in case no promise is returned.
      if (!checkIsPromise(resultPromise)) {
        throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
      }
    } else if (checkIsPromise(promiseFn)) {
      resultPromise = promiseFn;
    } else {
      throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);
    }
    return Promise.resolve().then(function () {
      return resultPromise;
    }).then(function () {
      return NO_EXCEPTION_SENTINEL;
    }).catch(function (e) {
      return e;
    });
  });
}
function expectsError(stackStartFn, actual, error, message) {
  if (typeof error === 'string') {
    if (arguments.length === 4) {
      throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
    }
    if (_typeof(actual) === 'object' && actual !== null) {
      if (actual.message === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
      }
    } else if (actual === error) {
      throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
    }
    message = error;
    error = undefined;
  } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
  }
  if (actual === NO_EXCEPTION_SENTINEL) {
    var details = '';
    if (error && error.name) {
      details += " (".concat(error.name, ")");
    }
    details += message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
    innerFail({
      actual: undefined,
      expected: error,
      operator: stackStartFn.name,
      message: "Missing expected ".concat(fnType).concat(details),
      stackStartFn: stackStartFn
    });
  }
  if (error && !expectedException(actual, error, message, stackStartFn)) {
    throw actual;
  }
}
function expectsNoError(stackStartFn, actual, error, message) {
  if (actual === NO_EXCEPTION_SENTINEL) return;
  if (typeof error === 'string') {
    message = error;
    error = undefined;
  }
  if (!error || expectedException(actual, error)) {
    var details = message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
    innerFail({
      actual: actual,
      expected: error,
      operator: stackStartFn.name,
      message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
      stackStartFn: stackStartFn
    });
  }
  throw actual;
}
assert.throws = function throws(promiseFn) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
};
assert.rejects = function rejects(promiseFn) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }
  return waitForActual(promiseFn).then(function (result) {
    return expectsError.apply(void 0, [rejects, result].concat(args));
  });
};
assert.doesNotThrow = function doesNotThrow(fn) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }
  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
};
assert.doesNotReject = function doesNotReject(fn) {
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }
  return waitForActual(fn).then(function (result) {
    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
  });
};
assert.ifError = function ifError(err) {
  if (err !== null && err !== undefined) {
    var message = 'ifError got unwanted exception: ';
    if (_typeof(err) === 'object' && typeof err.message === 'string') {
      if (err.message.length === 0 && err.constructor) {
        message += err.constructor.name;
      } else {
        message += err.message;
      }
    } else {
      message += inspect(err);
    }
    var newErr = new AssertionError({
      actual: err,
      expected: null,
      operator: 'ifError',
      message: message,
      stackStartFn: ifError
    });

    // Make sure we actually have a stack trace!
    var origStack = err.stack;
    if (typeof origStack === 'string') {
      // This will remove any duplicated frames from the error frames taken
      // from within `ifError` and add the original error frames to the newly
      // created ones.
      var tmp2 = origStack.split('\n');
      tmp2.shift();
      // Filter all frames existing in err.stack.
      var tmp1 = newErr.stack.split('\n');
      for (var i = 0; i < tmp2.length; i++) {
        // Find the first occurrence of the frame.
        var pos = tmp1.indexOf(tmp2[i]);
        if (pos !== -1) {
          // Only keep new frames.
          tmp1 = tmp1.slice(0, pos);
          break;
        }
      }
      newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
    }
    throw newErr;
  }
};

// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a871df3dfb8ea663ef5e1f8f62701ec51384ecb
function internalMatch(string, regexp, message, fn, fnName) {
  if (!isRegExp(regexp)) {
    throw new ERR_INVALID_ARG_TYPE('regexp', 'RegExp', regexp);
  }
  var match = fnName === 'match';
  if (typeof string !== 'string' || RegExpPrototypeTest(regexp, string) !== match) {
    if (message instanceof Error) {
      throw message;
    }
    var generatedMessage = !message;

    // 'The input was expected to not match the regular expression ' +
    message = message || (typeof string !== 'string' ? 'The "string" argument must be of type string. Received type ' + "".concat(_typeof(string), " (").concat(inspect(string), ")") : (match ? 'The input did not match the regular expression ' : 'The input was expected to not match the regular expression ') + "".concat(inspect(regexp), ". Input:\n\n").concat(inspect(string), "\n"));
    var err = new AssertionError({
      actual: string,
      expected: regexp,
      message: message,
      operator: fnName,
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
}
assert.match = function match(string, regexp, message) {
  internalMatch(string, regexp, message, match, 'match');
};
assert.doesNotMatch = function doesNotMatch(string, regexp, message) {
  internalMatch(string, regexp, message, doesNotMatch, 'doesNotMatch');
};

// Expose a strict only variant of assert
function strict() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }
  innerOk.apply(void 0, [strict, args.length].concat(args));
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

/***/ }),

/***/ 66979:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(82530);
// Currently in sync with Node.js lib/internal/assert/assertion_error.js
// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c



function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _require = __webpack_require__(85663),
  inspect = _require.inspect;
var _require2 = __webpack_require__(78619),
  ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
function repeat(str, count) {
  count = Math.floor(count);
  if (str.length == 0 || count == 0) return '';
  var maxCount = str.length * count;
  count = Math.floor(Math.log(count) / Math.log(2));
  while (count) {
    str += str;
    count--;
  }
  str += str.substring(0, maxCount - str.length);
  return str;
}
var blue = '';
var green = '';
var red = '';
var white = '';
var kReadableOperator = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:',
  notIdentical: 'Values identical but not reference-equal:'
};

// Comparing short primitives should just show === / !== instead of using the
// diff.
var kMaxShortLength = 10;
function copyError(source) {
  var keys = Object.keys(source);
  var target = Object.create(Object.getPrototypeOf(source));
  keys.forEach(function (key) {
    target[key] = source[key];
  });
  Object.defineProperty(target, 'message', {
    value: source.message
  });
  return target;
}
function inspectValue(val) {
  // The util.inspect default values could be changed. This makes sure the
  // error messages contain the necessary information nevertheless.
  return inspect(val, {
    compact: false,
    customInspect: false,
    depth: 1000,
    maxArrayLength: Infinity,
    // Assert compares only enumerable properties (with a few exceptions).
    showHidden: false,
    // Having a long line as error is better than wrapping the line for
    // comparison for now.
    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
    // have meta information about the inspected properties (i.e., know where
    // in what line the property starts and ends).
    breakLength: Infinity,
    // Assert does not detect proxies currently.
    showProxy: false,
    sorted: true,
    // Inspect getters as we also check them when comparing entries.
    getters: true
  });
}
function createErrDiff(actual, expected, operator) {
  var other = '';
  var res = '';
  var lastPos = 0;
  var end = '';
  var skipped = false;
  var actualInspected = inspectValue(actual);
  var actualLines = actualInspected.split('\n');
  var expectedLines = inspectValue(expected).split('\n');
  var i = 0;
  var indicator = '';

  // In case both values are objects explicitly mark them as not reference equal
  // for the `strictEqual` operator.
  if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
    operator = 'strictEqualObject';
  }

  // If "actual" and "expected" fit on a single line and they are not strictly
  // equal, check further special handling.
  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
    var inputLength = actualLines[0].length + expectedLines[0].length;
    // If the character length of "actual" and "expected" together is less than
    // kMaxShortLength and if neither is an object and at least one of them is
    // not `zero`, use the strict equal comparison to visualize the output.
    if (inputLength <= kMaxShortLength) {
      if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
        // -0 === +0
        return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
      }
    } else if (operator !== 'strictEqualObject') {
      // If the stderr is a tty and the input length is lower than the current
      // columns per line, add a mismatch indicator below the output. If it is
      // not a tty, use a default value of 80 characters.
      var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
      if (inputLength < maxLength) {
        while (actualLines[0][i] === expectedLines[0][i]) {
          i++;
        }
        // Ignore the first characters.
        if (i > 2) {
          // Add position indicator for the first mismatch in case it is a
          // single line and the input length is less than the column length.
          indicator = "\n  ".concat(repeat(' ', i), "^");
          i = 0;
        }
      }
    }
  }

  // Remove all ending lines that match (this optimizes the output for
  // readability by reducing the number of total changed lines).
  var a = actualLines[actualLines.length - 1];
  var b = expectedLines[expectedLines.length - 1];
  while (a === b) {
    if (i++ < 2) {
      end = "\n  ".concat(a).concat(end);
    } else {
      other = a;
    }
    actualLines.pop();
    expectedLines.pop();
    if (actualLines.length === 0 || expectedLines.length === 0) break;
    a = actualLines[actualLines.length - 1];
    b = expectedLines[expectedLines.length - 1];
  }
  var maxLines = Math.max(actualLines.length, expectedLines.length);
  // Strict equal with identical objects that are not identical by reference.
  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
  if (maxLines === 0) {
    // We have to get the result again. The lines were all removed before.
    var _actualLines = actualInspected.split('\n');

    // Only remove lines in case it makes sense to collapse those.
    // TODO: Accept env to always show the full error.
    if (_actualLines.length > 30) {
      _actualLines[26] = "".concat(blue, "...").concat(white);
      while (_actualLines.length > 27) {
        _actualLines.pop();
      }
    }
    return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
  }
  if (i > 3) {
    end = "\n".concat(blue, "...").concat(white).concat(end);
    skipped = true;
  }
  if (other !== '') {
    end = "\n  ".concat(other).concat(end);
    other = '';
  }
  var printedLines = 0;
  var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
  var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
  for (i = 0; i < maxLines; i++) {
    // Only extra expected lines exist
    var cur = i - lastPos;
    if (actualLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(expectedLines[i - 2]);
          printedLines++;
        }
        res += "\n  ".concat(expectedLines[i - 1]);
        printedLines++;
      }
      // Mark the current line as the last diverging one.
      lastPos = i;
      // Add the expected line to the cache.
      other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
      printedLines++;
      // Only extra actual lines exist
    } else if (expectedLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(actualLines[i - 2]);
          printedLines++;
        }
        res += "\n  ".concat(actualLines[i - 1]);
        printedLines++;
      }
      // Mark the current line as the last diverging one.
      lastPos = i;
      // Add the actual line to the result.
      res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
      printedLines++;
      // Lines diverge
    } else {
      var expectedLine = expectedLines[i];
      var actualLine = actualLines[i];
      // If the lines diverge, specifically check for lines that only diverge by
      // a trailing comma. In that case it is actually identical and we should
      // mark it as such.
      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine);
      // If the expected line has a trailing comma but is otherwise identical,
      // add a comma at the end of the actual line. Otherwise the output could
      // look weird as in:
      //
      //   [
      //     1         // No comma at the end!
      // +   2
      //   ]
      //
      if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
        divergingLines = false;
        actualLine += ',';
      }
      if (divergingLines) {
        // If the last diverging line is more than one line above and the
        // current line is at least line three, add some of the former lines and
        // also add dots to indicate skipped entries.
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i - 2]);
            printedLines++;
          }
          res += "\n  ".concat(actualLines[i - 1]);
          printedLines++;
        }
        // Mark the current line as the last diverging one.
        lastPos = i;
        // Add the actual line to the result and cache the expected diverging
        // line so consecutive diverging lines show up as +++--- and not +-+-+-.
        res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
        printedLines += 2;
        // Lines are identical
      } else {
        // Add all cached information to the result before adding other things
        // and reset the cache.
        res += other;
        other = '';
        // If the last diverging line is exactly one line above or if it is the
        // very first line, add the line to the result.
        if (cur === 1 || i === 0) {
          res += "\n  ".concat(actualLine);
          printedLines++;
        }
      }
    }
    // Inspected object to big (Show ~20 rows max)
    if (printedLines > 20 && i < maxLines - 2) {
      return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
    }
  }
  return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
}
var AssertionError = /*#__PURE__*/function (_Error, _inspect$custom) {
  _inherits(AssertionError, _Error);
  var _super = _createSuper(AssertionError);
  function AssertionError(options) {
    var _this;
    _classCallCheck(this, AssertionError);
    if (_typeof(options) !== 'object' || options === null) {
      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }
    var message = options.message,
      operator = options.operator,
      stackStartFn = options.stackStartFn;
    var actual = options.actual,
      expected = options.expected;
    var limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    if (message != null) {
      _this = _super.call(this, String(message));
    } else {
      if (process.stderr && process.stderr.isTTY) {
        // Reset on each call to make sure we handle dynamically set environment
        // variables correct.
        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
          blue = "\x1B[34m";
          green = "\x1B[32m";
          white = "\x1B[39m";
          red = "\x1B[31m";
        } else {
          blue = '';
          green = '';
          white = '';
          red = '';
        }
      }
      // Prevent the error stack from being visible by duplicating the error
      // in a very close way to the original in case both sides are actually
      // instances of Error.
      if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
        actual = copyError(actual);
        expected = copyError(expected);
      }
      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
        _this = _super.call(this, createErrDiff(actual, expected, operator));
      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
        // In case the objects are equal but the operator requires unequal, show
        // the first object and say A equals B
        var base = kReadableOperator[operator];
        var res = inspectValue(actual).split('\n');

        // In case "actual" is an object, it should not be reference equal.
        if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
          base = kReadableOperator.notStrictEqualObject;
        }

        // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.
        if (res.length > 30) {
          res[26] = "".concat(blue, "...").concat(white);
          while (res.length > 27) {
            res.pop();
          }
        }

        // Only print a single input.
        if (res.length === 1) {
          _this = _super.call(this, "".concat(base, " ").concat(res[0]));
        } else {
          _this = _super.call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n"));
        }
      } else {
        var _res = inspectValue(actual);
        var other = '';
        var knownOperators = kReadableOperator[operator];
        if (operator === 'notDeepEqual' || operator === 'notEqual') {
          _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
          if (_res.length > 1024) {
            _res = "".concat(_res.slice(0, 1021), "...");
          }
        } else {
          other = "".concat(inspectValue(expected));
          if (_res.length > 512) {
            _res = "".concat(_res.slice(0, 509), "...");
          }
          if (other.length > 512) {
            other = "".concat(other.slice(0, 509), "...");
          }
          if (operator === 'deepEqual' || operator === 'equal') {
            _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
          } else {
            other = " ".concat(operator, " ").concat(other);
          }
        }
        _this = _super.call(this, "".concat(_res).concat(other));
      }
    }
    Error.stackTraceLimit = limit;
    _this.generatedMessage = !message;
    Object.defineProperty(_assertThisInitialized(_this), 'name', {
      value: 'AssertionError [ERR_ASSERTION]',
      enumerable: false,
      writable: true,
      configurable: true
    });
    _this.code = 'ERR_ASSERTION';
    _this.actual = actual;
    _this.expected = expected;
    _this.operator = operator;
    if (Error.captureStackTrace) {
      // eslint-disable-next-line no-restricted-syntax
      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
    }
    // Create error message including the error code in the name.
    _this.stack;
    // Reset the name.
    _this.name = 'AssertionError';
    return _possibleConstructorReturn(_this);
  }
  _createClass(AssertionError, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    }
  }, {
    key: _inspect$custom,
    value: function value(recurseTimes, ctx) {
      // This limits the `actual` and `expected` property default inspection to
      // the minimum depth. Otherwise those values would be too verbose compared
      // to the actual error message which contains a combined view of these two
      // input values.
      return inspect(this, _objectSpread(_objectSpread({}, ctx), {}, {
        customInspect: false,
        depth: 0
      }));
    }
  }]);
  return AssertionError;
}( /*#__PURE__*/_wrapNativeSuper(Error), inspect.custom);
module.exports = AssertionError;

/***/ }),

/***/ 78619:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/errors.js
// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f

/* eslint node-core/documented-errors: "error" */
/* eslint node-core/alphabetize-errors: "error" */
/* eslint node-core/prefer-util-format-errors: "error" */



// The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var codes = {};

// Lazy loaded
var assert;
var util;
function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = /*#__PURE__*/function (_Base) {
    _inherits(NodeError, _Base);
    var _super = _createSuper(NodeError);
    function NodeError(arg1, arg2, arg3) {
      var _this;
      _classCallCheck(this, NodeError);
      _this = _super.call(this, getMessage(arg1, arg2, arg3));
      _this.code = code;
      return _this;
    }
    return _createClass(NodeError);
  }(Base);
  codes[code] = NodeError;
}

// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }
  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}
createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  if (assert === undefined) assert = __webpack_require__(76118);
  assert(typeof name === 'string', "'name' must be a string");

  // determiner: 'must be' or 'must not be'
  var determiner;
  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }
  var msg;
  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  // TODO(BridgeAR): Improve the output by showing `null` and similar.
  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {
  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
  if (util === undefined) util = __webpack_require__(85663);
  var inspected = util.inspect(value);
  if (inspected.length > 128) {
    inspected = "".concat(inspected.slice(0, 128), "...");
  }
  return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError, RangeError);
createErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {
  var type;
  if (value && value.constructor && value.constructor.name) {
    type = "instance of ".concat(value.constructor.name);
  } else {
    type = "type ".concat(_typeof(value));
  }
  return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
}, TypeError);
createErrorType('ERR_MISSING_ARGS', function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (assert === undefined) assert = __webpack_require__(76118);
  assert(args.length > 0, 'At least one arg needs to be specified');
  var msg = 'The ';
  var len = args.length;
  args = args.map(function (a) {
    return "\"".concat(a, "\"");
  });
  switch (len) {
    case 1:
      msg += "".concat(args[0], " argument");
      break;
    case 2:
      msg += "".concat(args[0], " and ").concat(args[1], " arguments");
      break;
    default:
      msg += args.slice(0, len - 1).join(', ');
      msg += ", and ".concat(args[len - 1], " arguments");
      break;
  }
  return "".concat(msg, " must be specified");
}, TypeError);
module.exports.codes = codes;

/***/ }),

/***/ 61667:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/comparisons.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var regexFlagsSupported = /a/g.flags !== undefined;
var arrayFromSet = function arrayFromSet(set) {
  var array = [];
  set.forEach(function (value) {
    return array.push(value);
  });
  return array;
};
var arrayFromMap = function arrayFromMap(map) {
  var array = [];
  map.forEach(function (value, key) {
    return array.push([key, value]);
  });
  return array;
};
var objectIs = Object.is ? Object.is : __webpack_require__(7402);
var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {
  return [];
};
var numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__(98622);
function uncurryThis(f) {
  return f.call.bind(f);
}
var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
var objectToString = uncurryThis(Object.prototype.toString);
var _require$types = (__webpack_require__(85663).types),
  isAnyArrayBuffer = _require$types.isAnyArrayBuffer,
  isArrayBufferView = _require$types.isArrayBufferView,
  isDate = _require$types.isDate,
  isMap = _require$types.isMap,
  isRegExp = _require$types.isRegExp,
  isSet = _require$types.isSet,
  isNativeError = _require$types.isNativeError,
  isBoxedPrimitive = _require$types.isBoxedPrimitive,
  isNumberObject = _require$types.isNumberObject,
  isStringObject = _require$types.isStringObject,
  isBooleanObject = _require$types.isBooleanObject,
  isBigIntObject = _require$types.isBigIntObject,
  isSymbolObject = _require$types.isSymbolObject,
  isFloat32Array = _require$types.isFloat32Array,
  isFloat64Array = _require$types.isFloat64Array;
function isNonIndex(key) {
  if (key.length === 0 || key.length > 10) return true;
  for (var i = 0; i < key.length; i++) {
    var code = key.charCodeAt(i);
    if (code < 48 || code > 57) return true;
  }
  // The maximum size for an array is 2 ** 32 -1.
  return key.length === 10 && key >= Math.pow(2, 32);
}
function getOwnNonIndexProperties(value) {
  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
}

// Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
var ONLY_ENUMERABLE = undefined;
var kStrict = true;
var kLoose = false;
var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3;

// Check if they have the same source and flags
function areSimilarRegExps(a, b) {
  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
}
function areSimilarFloatArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (var offset = 0; offset < a.byteLength; offset++) {
    if (a[offset] !== b[offset]) {
      return false;
    }
  }
  return true;
}
function areSimilarTypedArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(val1, val2) {
  if (isNumberObject(val1)) {
    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
  }
  if (isStringObject(val1)) {
    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
  }
  if (isBooleanObject(val1)) {
    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
  }
  if (isBigIntObject(val1)) {
    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
  }
  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
}

// Notes: Type tags are historical [[Class]] properties that can be set by
// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
// and retrieved using Object.prototype.toString.call(obj) in JS
// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
// for a list of tags pre-defined in the spec.
// There are some unspecified tags in the wild too (e.g. typed array tags).
// Since tags can be altered, they only serve fast failures
//
// Typed arrays and buffers are checked by comparing the content in their
// underlying ArrayBuffer. This optimization requires that it's
// reasonable to interpret their underlying memory in the same way,
// which is checked by comparing their type tags.
// (e.g. a Uint8Array and a Uint16Array with the same memory content
// could still be different because they will be interpreted differently).
//
// For strict comparison, objects should have
// a) The same built-in type tags
// b) The same prototypes.

function innerDeepEqual(val1, val2, strict, memos) {
  // All identical values are equivalent, as determined by ===.
  if (val1 === val2) {
    if (val1 !== 0) return true;
    return strict ? objectIs(val1, val2) : true;
  }

  // Check more closely if val1 and val2 are equal.
  if (strict) {
    if (_typeof(val1) !== 'object') {
      return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
    }
    if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
      return false;
    }
    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || _typeof(val1) !== 'object') {
      if (val2 === null || _typeof(val2) !== 'object') {
        // eslint-disable-next-line eqeqeq
        return val1 == val2;
      }
      return false;
    }
    if (val2 === null || _typeof(val2) !== 'object') {
      return false;
    }
  }
  var val1Tag = objectToString(val1);
  var val2Tag = objectToString(val2);
  if (val1Tag !== val2Tag) {
    return false;
  }
  if (Array.isArray(val1)) {
    // Check for sparse arrays and general fast path
    if (val1.length !== val2.length) {
      return false;
    }
    var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
    if (keys1.length !== keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
  }
  // [browserify] This triggers on certain types in IE (Map/Set) so we don't
  // wan't to early return out of the rest of the checks. However we can check
  // if the second value is one of these values and the first isn't.
  if (val1Tag === '[object Object]') {
    // return keyCheck(val1, val2, strict, memos, kNoIterator);
    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
      return false;
    }
  }
  if (isDate(val1)) {
    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
      return false;
    }
  } else if (isRegExp(val1)) {
    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if (isNativeError(val1) || val1 instanceof Error) {
    // Do not compare the stack as it might differ even though the error itself
    // is otherwise identical.
    if (val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView(val1)) {
    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
      if (!areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    }
    // Buffer.compare returns true, so val1.length === val2.length. If they both
    // only contain numeric keys, we don't need to exam further than checking
    // the symbols.
    var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
    if (_keys.length !== _keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
  } else if (isSet(val1)) {
    if (!isSet(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsSet);
  } else if (isMap(val1)) {
    if (!isMap(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsMap);
  } else if (isAnyArrayBuffer(val1)) {
    if (!areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
    return false;
  }
  return keyCheck(val1, val2, strict, memos, kNoIterator);
}
function getEnumerables(val, keys) {
  return keys.filter(function (k) {
    return propertyIsEnumerable(val, k);
  });
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
  // For all remaining Object pairs, including Array, objects and Maps,
  // equivalence is determined by having:
  // a) The same number of owned enumerable properties
  // b) The same set of keys/indexes (although not necessarily the same order)
  // c) Equivalent values for every corresponding key/index
  // d) For Sets and Maps, equal contents
  // Note: this accounts for both named and indexed properties on Arrays.
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    var bKeys = Object.keys(val2);

    // The pair must have the same number of owned properties.
    if (aKeys.length !== bKeys.length) {
      return false;
    }
  }

  // Cheap key test
  var i = 0;
  for (; i < aKeys.length; i++) {
    if (!hasOwnProperty(val2, aKeys[i])) {
      return false;
    }
  }
  if (strict && arguments.length === 5) {
    var symbolKeysA = objectGetOwnPropertySymbols(val1);
    if (symbolKeysA.length !== 0) {
      var count = 0;
      for (i = 0; i < symbolKeysA.length; i++) {
        var key = symbolKeysA[i];
        if (propertyIsEnumerable(val1, key)) {
          if (!propertyIsEnumerable(val2, key)) {
            return false;
          }
          aKeys.push(key);
          count++;
        } else if (propertyIsEnumerable(val2, key)) {
          return false;
        }
      }
      var symbolKeysB = objectGetOwnPropertySymbols(val2);
      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      var _symbolKeysB = objectGetOwnPropertySymbols(val2);
      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
        return false;
      }
    }
  }
  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
    return true;
  }

  // Use memos to handle cycles.
  if (memos === undefined) {
    memos = {
      val1: new Map(),
      val2: new Map(),
      position: 0
    };
  } else {
    // We prevent up to two map.has(x) calls by directly retrieving the value
    // and checking for undefined. The map can only contain numbers, so it is
    // safe to check for undefined only.
    var val2MemoA = memos.val1.get(val1);
    if (val2MemoA !== undefined) {
      var val2MemoB = memos.val2.get(val2);
      if (val2MemoB !== undefined) {
        return val2MemoA === val2MemoB;
      }
    }
    memos.position++;
  }
  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}
function setHasEqualElement(set, val1, strict, memo) {
  // Go looking.
  var setValues = arrayFromSet(set);
  for (var i = 0; i < setValues.length; i++) {
    var val2 = setValues[i];
    if (innerDeepEqual(val1, val2, strict, memo)) {
      // Remove the matching element to make sure we do not check that again.
      set.delete(val2);
      return true;
    }
  }
  return false;
}

// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
// Sadly it is not possible to detect corresponding values properly in case the
// type is a string, number, bigint or boolean. The reason is that those values
// can match lots of different string values (e.g., 1n == '+00001').
function findLooseMatchingPrimitives(prim) {
  switch (_typeof(prim)) {
    case 'undefined':
      return null;
    case 'object':
      // Only pass in null as object!
      return undefined;
    case 'symbol':
      return false;
    case 'string':
      prim = +prim;
    // Loose equal entries exist only if the string is possible to convert to
    // a regular number and not NaN.
    // Fall through
    case 'number':
      if (numberIsNaN(prim)) {
        return false;
      }
  }
  return true;
}
function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) return altValue;
  return b.has(altValue) && !a.has(altValue);
}
function mapMightHaveLoosePrim(a, b, prim, item, memo) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  var curB = b.get(altValue);
  if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
    return false;
  }
  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
}
function setEquiv(a, b, strict, memo) {
  // This is a lazily initiated Set of entries which have to be compared
  // pairwise.
  var set = null;
  var aValues = arrayFromSet(a);
  for (var i = 0; i < aValues.length; i++) {
    var val = aValues[i];
    // Note: Checking for the objects first improves the performance for object
    // heavy sets but it is a minor slow down for primitives. As they are fast
    // to check this improves the worst case scenario instead.
    if (_typeof(val) === 'object' && val !== null) {
      if (set === null) {
        set = new Set();
      }
      // If the specified value doesn't exist in the second set its an not null
      // object (or non strict only: a not matching primitive) we'll need to go
      // hunting for something thats deep-(strict-)equal to it. To make this
      // O(n log n) complexity we have to copy these values in a new set first.
      set.add(val);
    } else if (!b.has(val)) {
      if (strict) return false;

      // Fast path to detect missing string, symbol, undefined and null values.
      if (!setMightHaveLoosePrim(a, b, val)) {
        return false;
      }
      if (set === null) {
        set = new Set();
      }
      set.add(val);
    }
  }
  if (set !== null) {
    var bValues = arrayFromSet(b);
    for (var _i = 0; _i < bValues.length; _i++) {
      var _val = bValues[_i];
      // We have to check if a primitive value is already
      // matching and only if it's not, go hunting for it.
      if (_typeof(_val) === 'object' && _val !== null) {
        if (!setHasEqualElement(set, _val, strict, memo)) return false;
      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
  // To be able to handle cases like:
  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
  // ... we need to consider *all* matching keys, not just the first we find.
  var setValues = arrayFromSet(set);
  for (var i = 0; i < setValues.length; i++) {
    var key2 = setValues[i];
    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
      set.delete(key2);
      return true;
    }
  }
  return false;
}
function mapEquiv(a, b, strict, memo) {
  var set = null;
  var aEntries = arrayFromMap(a);
  for (var i = 0; i < aEntries.length; i++) {
    var _aEntries$i = _slicedToArray(aEntries[i], 2),
      key = _aEntries$i[0],
      item1 = _aEntries$i[1];
    if (_typeof(key) === 'object' && key !== null) {
      if (set === null) {
        set = new Set();
      }
      set.add(key);
    } else {
      // By directly retrieving the value we prevent another b.has(key) check in
      // almost all possible cases.
      var item2 = b.get(key);
      if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
        if (strict) return false;
        // Fast path to detect missing string, symbol, undefined and null
        // keys.
        if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
        if (set === null) {
          set = new Set();
        }
        set.add(key);
      }
    }
  }
  if (set !== null) {
    var bEntries = arrayFromMap(b);
    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),
        _key = _bEntries$_i[0],
        item = _bEntries$_i[1];
      if (_typeof(_key) === 'object' && _key !== null) {
        if (!mapHasEqualEntry(set, a, _key, item, strict, memo)) return false;
      } else if (!strict && (!a.has(_key) || !innerDeepEqual(a.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a, _key, item, false, memo)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function objEquiv(a, b, strict, keys, memos, iterationType) {
  // Sets and maps don't have their entries accessible via normal object
  // properties.
  var i = 0;
  if (iterationType === kIsSet) {
    if (!setEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsMap) {
    if (!mapEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsArray) {
    for (; i < a.length; i++) {
      if (hasOwnProperty(a, i)) {
        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
          return false;
        }
      } else if (hasOwnProperty(b, i)) {
        return false;
      } else {
        // Array is sparse.
        var keysA = Object.keys(a);
        for (; i < keysA.length; i++) {
          var key = keysA[i];
          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
            return false;
          }
        }
        if (keysA.length !== Object.keys(b).length) {
          return false;
        }
        return true;
      }
    }
  }

  // The pair must have equivalent values for every corresponding key.
  // Possibly expensive deep test:
  for (i = 0; i < keys.length; i++) {
    var _key2 = keys[i];
    if (!innerDeepEqual(a[_key2], b[_key2], strict, memos)) {
      return false;
    }
  }
  return true;
}
function isDeepEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kLoose);
}
function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kStrict);
}
module.exports = {
  isDeepEqual: isDeepEqual,
  isDeepStrictEqual: isDeepStrictEqual
};

/***/ }),

/***/ 97615:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(31801);

var callBind = __webpack_require__(12550);

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ 12550:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(21930);
var GetIntrinsic = __webpack_require__(31801);

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ 80292:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*global window, global*/
var util = __webpack_require__(85663)
var assert = __webpack_require__(76118)
function now() { return new Date().getTime() }

var slice = Array.prototype.slice
var console
var times = {}

if (typeof __webpack_require__.g !== "undefined" && __webpack_require__.g.console) {
    console = __webpack_require__.g.console
} else if (typeof window !== "undefined" && window.console) {
    console = window.console
} else {
    console = {}
}

var functions = [
    [log, "log"],
    [info, "info"],
    [warn, "warn"],
    [error, "error"],
    [time, "time"],
    [timeEnd, "timeEnd"],
    [trace, "trace"],
    [dir, "dir"],
    [consoleAssert, "assert"]
]

for (var i = 0; i < functions.length; i++) {
    var tuple = functions[i]
    var f = tuple[0]
    var name = tuple[1]

    if (!console[name]) {
        console[name] = f
    }
}

module.exports = console

function log() {}

function info() {
    console.log.apply(console, arguments)
}

function warn() {
    console.log.apply(console, arguments)
}

function error() {
    console.warn.apply(console, arguments)
}

function time(label) {
    times[label] = now()
}

function timeEnd(label) {
    var time = times[label]
    if (!time) {
        throw new Error("No such label: " + label)
    }

    delete times[label]
    var duration = now() - time
    console.log(label + ": " + duration + "ms")
}

function trace() {
    var err = new Error()
    err.name = "Trace"
    err.message = util.format.apply(null, arguments)
    console.error(err.stack)
}

function dir(object) {
    console.log(util.inspect(object) + "\n")
}

function consoleAssert(expression) {
    if (!expression) {
        var arr = slice.call(arguments, 1)
        assert.ok(false, util.format.apply(null, arr))
    }
}


/***/ }),

/***/ 19170:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keys = __webpack_require__(806);
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var hasPropertyDescriptors = __webpack_require__(28198)();

var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;

var defineProperty = function (object, name, value, predicate) {
	if (name in object) {
		if (predicate === true) {
			if (object[name] === value) {
				return;
			}
		} else if (!isFunction(predicate) || !predicate()) {
			return;
		}
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value; // eslint-disable-line no-param-reassign
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


/***/ }),

/***/ 94843:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isCallable = __webpack_require__(5443);

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

var forEach = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (toStr.call(list) === '[object Array]') {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};

module.exports = forEach;


/***/ }),

/***/ 19930:
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ 21930:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(19930);

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ 31801:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(99905)();
var hasProto = __webpack_require__(11856)();

var getProto = Object.getPrototypeOf || (
	hasProto
		? function (x) { return x.__proto__; } // eslint-disable-line no-proto
		: null
);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(21930);
var hasOwn = __webpack_require__(79284);
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ 93828:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(31801);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ 28198:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(31801);

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	if ($defineProperty) {
		try {
			$defineProperty({}, 'a', { value: 1 });
			return true;
		} catch (e) {
			// IE 8 has a broken defineProperty
			return false;
		}
	}
	return false;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!hasPropertyDescriptors()) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;


/***/ }),

/***/ 11856:
/***/ ((module) => {

"use strict";


var test = {
	foo: {}
};

var $Object = Object;

module.exports = function hasProto() {
	return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
};


/***/ }),

/***/ 99905:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(65682);

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ 65682:
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ 44111:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(65682);

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


/***/ }),

/***/ 79284:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(21930);

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),

/***/ 44523:
/***/ ((module) => {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    // eslint-disable-next-line no-param-reassign
    options = {};
  }

  if (!url) {
    return url;
  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign


  url = String(url.__esModule ? url.default : url);

  if (options.hash) {
    // eslint-disable-next-line no-param-reassign
    url += options.hash;
  }

  if (options.maybeNeedQuotes && /[\t\n\f\r "'=<>`]/.test(url)) {
    return "\"".concat(url, "\"");
  }

  return url;
};

/***/ }),

/***/ 48575:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 77092:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasToStringTag = __webpack_require__(44111)();
var callBound = __webpack_require__(97615);

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


/***/ }),

/***/ 5443:
/***/ ((module) => {

"use strict";


var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
		// eslint-disable-next-line no-throw-literal
		reflectApply(function () { throw 42; }, null, badArrayLike);
	} catch (_) {
		if (_ !== isCallableMarker) {
			reflectApply = null;
		}
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() { return false; };
if (typeof document === 'object') {
	// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
	var all = document.all;
	if (toStr.call(all) === toStr.call(document.all)) {
		isDDA = function isDocumentDotAll(value) {
			/* globals document: false */
			// in IE 6-8, typeof document.all is "object" and it's truthy
			if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
				try {
					var str = toStr.call(value);
					return (
						str === ddaClass
						|| str === ddaClass2
						|| str === ddaClass3 // opera 12.16
						|| str === objectClass // IE 6-8
					) && value('') == null; // eslint-disable-line eqeqeq
				} catch (e) { /**/ }
			}
			return false;
		};
	}
}

module.exports = reflectApply
	? function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value) && tryFunctionObject(value);
	}
	: function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		if (strClass !== fnClass && strClass !== genClass && !(/^\[object HTML/).test(strClass)) { return false; }
		return tryFunctionObject(value);
	};


/***/ }),

/***/ 97427:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = __webpack_require__(44111)();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var GeneratorFunction;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
	}
	return getProto(fn) === GeneratorFunction;
};


/***/ }),

/***/ 82100:
/***/ ((module) => {

"use strict";


/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function isNaN(value) {
	return value !== value;
};


/***/ }),

/***/ 98622:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(12550);
var define = __webpack_require__(19170);

var implementation = __webpack_require__(82100);
var getPolyfill = __webpack_require__(64358);
var shim = __webpack_require__(6232);

var polyfill = callBind(getPolyfill(), Number);

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ 64358:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(82100);

module.exports = function getPolyfill() {
	if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
		return Number.isNaN;
	}
	return implementation;
};


/***/ }),

/***/ 6232:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(19170);
var getPolyfill = __webpack_require__(64358);

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function shimNumberIsNaN() {
	var polyfill = getPolyfill();
	define(Number, { isNaN: polyfill }, {
		isNaN: function testIsNaN() {
			return Number.isNaN !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ 82527:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var whichTypedArray = __webpack_require__(54010);

module.exports = function isTypedArray(value) {
	return !!whichTypedArray(value);
};


/***/ }),

/***/ 98720:
/***/ ((module) => {

"use strict";


var numberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	}
	if (a === b) {
		return true;
	}
	if (numberIsNaN(a) && numberIsNaN(b)) {
		return true;
	}
	return false;
};



/***/ }),

/***/ 7402:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(19170);
var callBind = __webpack_require__(12550);

var implementation = __webpack_require__(98720);
var getPolyfill = __webpack_require__(25280);
var shim = __webpack_require__(49129);

var polyfill = callBind(getPolyfill(), Object);

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ 25280:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(98720);

module.exports = function getPolyfill() {
	return typeof Object.is === 'function' ? Object.is : implementation;
};


/***/ }),

/***/ 49129:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getPolyfill = __webpack_require__(25280);
var define = __webpack_require__(19170);

module.exports = function shimObjectIs() {
	var polyfill = getPolyfill();
	define(Object, { is: polyfill }, {
		is: function testObjectIs() {
			return Object.is !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ 78383:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = __webpack_require__(84418); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;


/***/ }),

/***/ 806:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(84418);

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(78383);

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),

/***/ 84418:
/***/ ((module) => {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),

/***/ 22148:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// modified from https://github.com/es-shims/es6-shim
var objectKeys = __webpack_require__(806);
var hasSymbols = __webpack_require__(65682)();
var callBound = __webpack_require__(97615);
var toObject = Object;
var $push = callBound('Array.prototype.push');
var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');
var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;

// eslint-disable-next-line no-unused-vars
module.exports = function assign(target, source1) {
	if (target == null) { throw new TypeError('target must be an object'); }
	var to = toObject(target); // step 1
	if (arguments.length === 1) {
		return to; // step 2
	}
	for (var s = 1; s < arguments.length; ++s) {
		var from = toObject(arguments[s]); // step 3.a.i

		// step 3.a.ii:
		var keys = objectKeys(from);
		var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
		if (getSymbols) {
			var syms = getSymbols(from);
			for (var j = 0; j < syms.length; ++j) {
				var key = syms[j];
				if ($propIsEnumerable(from, key)) {
					$push(keys, key);
				}
			}
		}

		// step 3.a.iii:
		for (var i = 0; i < keys.length; ++i) {
			var nextKey = keys[i];
			if ($propIsEnumerable(from, nextKey)) { // step 3.a.iii.2
				var propValue = from[nextKey]; // step 3.a.iii.2.a
				to[nextKey] = propValue; // step 3.a.iii.2.b
			}
		}
	}

	return to; // step 4
};


/***/ }),

/***/ 10293:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(22148);

var lacksProperEnumerationOrder = function () {
	if (!Object.assign) {
		return false;
	}
	/*
	 * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
	 * note: this does not detect the bug unless there's 20 characters
	 */
	var str = 'abcdefghijklmnopqrst';
	var letters = str.split('');
	var map = {};
	for (var i = 0; i < letters.length; ++i) {
		map[letters[i]] = letters[i];
	}
	var obj = Object.assign({}, map);
	var actual = '';
	for (var k in obj) {
		actual += k;
	}
	return str !== actual;
};

var assignHasPendingExceptions = function () {
	if (!Object.assign || !Object.preventExtensions) {
		return false;
	}
	/*
	 * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
	 * which is 72% slower than our shim, and Firefox 40's native implementation.
	 */
	var thrower = Object.preventExtensions({ 1: 2 });
	try {
		Object.assign(thrower, 'xy');
	} catch (e) {
		return thrower[1] === 'y';
	}
	return false;
};

module.exports = function getPolyfill() {
	if (!Object.assign) {
		return implementation;
	}
	if (lacksProperEnumerationOrder()) {
		return implementation;
	}
	if (assignHasPendingExceptions()) {
		return implementation;
	}
	return Object.assign;
};


/***/ }),

/***/ 82530:
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ 18628:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(50), exports);
__exportStar(__webpack_require__(14281), exports);
__exportStar(__webpack_require__(92872), exports);
__exportStar(__webpack_require__(51051), exports);
__exportStar(__webpack_require__(1297), exports);
__exportStar(__webpack_require__(53741), exports);
__exportStar(__webpack_require__(67841), exports);


/***/ }),

/***/ 50:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BlankNode = void 0;
/**
 * A term that represents an RDF blank node with a label.
 */
class BlankNode {
    constructor(value) {
        this.termType = 'BlankNode';
        this.value = value;
    }
    equals(other) {
        return !!other && other.termType === 'BlankNode' && other.value === this.value;
    }
}
exports.BlankNode = BlankNode;


/***/ }),

/***/ 14281:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataFactory = void 0;
const BlankNode_1 = __webpack_require__(50);
const DefaultGraph_1 = __webpack_require__(92872);
const Literal_1 = __webpack_require__(51051);
const NamedNode_1 = __webpack_require__(1297);
const Quad_1 = __webpack_require__(53741);
const Variable_1 = __webpack_require__(67841);
let dataFactoryCounter = 0;
/**
 * A factory for instantiating RDF terms and quads.
 */
class DataFactory {
    constructor(options) {
        this.blankNodeCounter = 0;
        options = options || {};
        this.blankNodePrefix = options.blankNodePrefix || `df_${dataFactoryCounter++}_`;
    }
    /**
     * @param value The IRI for the named node.
     * @return A new instance of NamedNode.
     * @see NamedNode
     */
    namedNode(value) {
        return new NamedNode_1.NamedNode(value);
    }
    /**
     * @param value The optional blank node identifier.
     * @return A new instance of BlankNode.
     *         If the `value` parameter is undefined a new identifier
     *         for the blank node is generated for each call.
     * @see BlankNode
     */
    blankNode(value) {
        return new BlankNode_1.BlankNode(value || `${this.blankNodePrefix}${this.blankNodeCounter++}`);
    }
    /**
     * @param value              The literal value.
     * @param languageOrDatatype The optional language or datatype.
     *                           If `languageOrDatatype` is a NamedNode,
     *                           then it is used for the value of `NamedNode.datatype`.
     *                           Otherwise `languageOrDatatype` is used for the value
     *                           of `NamedNode.language`.
     * @return A new instance of Literal.
     * @see Literal
     */
    literal(value, languageOrDatatype) {
        return new Literal_1.Literal(value, languageOrDatatype);
    }
    /**
     * This method is optional.
     * @param value The variable name
     * @return A new instance of Variable.
     * @see Variable
     */
    variable(value) {
        return new Variable_1.Variable(value);
    }
    /**
     * @return An instance of DefaultGraph.
     */
    defaultGraph() {
        return DefaultGraph_1.DefaultGraph.INSTANCE;
    }
    /**
     * @param subject   The quad subject term.
     * @param predicate The quad predicate term.
     * @param object    The quad object term.
     * @param graph     The quad graph term.
     * @return A new instance of Quad.
     * @see Quad
     */
    quad(subject, predicate, object, graph) {
        return new Quad_1.Quad(subject, predicate, object, graph || this.defaultGraph());
    }
    /**
     * Create a deep copy of the given term using this data factory.
     * @param original An RDF term.
     * @return A deep copy of the given term.
     */
    fromTerm(original) {
        // TODO: remove nasty any casts when this TS bug has been fixed:
        //  https://github.com/microsoft/TypeScript/issues/26933
        switch (original.termType) {
            case 'NamedNode':
                return this.namedNode(original.value);
            case 'BlankNode':
                return this.blankNode(original.value);
            case 'Literal':
                if (original.language) {
                    return this.literal(original.value, original.language);
                }
                if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {
                    return this.literal(original.value, this.fromTerm(original.datatype));
                }
                return this.literal(original.value);
            case 'Variable':
                return this.variable(original.value);
            case 'DefaultGraph':
                return this.defaultGraph();
            case 'Quad':
                return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));
        }
    }
    /**
     * Create a deep copy of the given quad using this data factory.
     * @param original An RDF quad.
     * @return A deep copy of the given quad.
     */
    fromQuad(original) {
        return this.fromTerm(original);
    }
    /**
     * Reset the internal blank node counter.
     */
    resetBlankNodeCounter() {
        this.blankNodeCounter = 0;
    }
}
exports.DataFactory = DataFactory;


/***/ }),

/***/ 92872:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultGraph = void 0;
/**
 * A singleton term instance that represents the default graph.
 * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.
 */
class DefaultGraph {
    constructor() {
        this.termType = 'DefaultGraph';
        this.value = '';
        // Private constructor
    }
    equals(other) {
        return !!other && other.termType === 'DefaultGraph';
    }
}
exports.DefaultGraph = DefaultGraph;
DefaultGraph.INSTANCE = new DefaultGraph();


/***/ }),

/***/ 51051:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Literal = void 0;
const NamedNode_1 = __webpack_require__(1297);
/**
 * A term that represents an RDF literal, containing a string with an optional language tag or datatype.
 */
class Literal {
    constructor(value, languageOrDatatype) {
        this.termType = 'Literal';
        this.value = value;
        if (typeof languageOrDatatype === 'string') {
            this.language = languageOrDatatype;
            this.datatype = Literal.RDF_LANGUAGE_STRING;
        }
        else if (languageOrDatatype) {
            this.language = '';
            this.datatype = languageOrDatatype;
        }
        else {
            this.language = '';
            this.datatype = Literal.XSD_STRING;
        }
    }
    equals(other) {
        return !!other && other.termType === 'Literal' && other.value === this.value &&
            other.language === this.language && this.datatype.equals(other.datatype);
    }
}
exports.Literal = Literal;
Literal.RDF_LANGUAGE_STRING = new NamedNode_1.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');
Literal.XSD_STRING = new NamedNode_1.NamedNode('http://www.w3.org/2001/XMLSchema#string');


/***/ }),

/***/ 1297:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NamedNode = void 0;
/**
 * A term that contains an IRI.
 */
class NamedNode {
    constructor(value) {
        this.termType = 'NamedNode';
        this.value = value;
    }
    equals(other) {
        return !!other && other.termType === 'NamedNode' && other.value === this.value;
    }
}
exports.NamedNode = NamedNode;


/***/ }),

/***/ 53741:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Quad = void 0;
/**
 * An instance of DefaultGraph represents the default graph.
 * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.
 */
class Quad {
    constructor(subject, predicate, object, graph) {
        this.termType = 'Quad';
        this.value = '';
        this.subject = subject;
        this.predicate = predicate;
        this.object = object;
        this.graph = graph;
    }
    equals(other) {
        // `|| !other.termType` is for backwards-compatibility with old factories without RDF* support.
        return !!other && (other.termType === 'Quad' || !other.termType) &&
            this.subject.equals(other.subject) &&
            this.predicate.equals(other.predicate) &&
            this.object.equals(other.object) &&
            this.graph.equals(other.graph);
    }
}
exports.Quad = Quad;


/***/ }),

/***/ 67841:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Variable = void 0;
/**
 * A term that represents a variable.
 */
class Variable {
    constructor(value) {
        this.termType = 'Variable';
        this.value = value;
    }
    equals(other) {
        return !!other && other.termType === 'Variable' && other.value === this.value;
    }
}
exports.Variable = Variable;


/***/ }),

/***/ 54870:
/***/ ((module) => {

var XSD_INTEGER = 'http://www.w3.org/2001/XMLSchema#integer';
var XSD_STRING = 'http://www.w3.org/2001/XMLSchema#string';

function Generator(options) {
  this._options = options = options || {};

  var prefixes = options.prefixes || {};
  this._prefixByIri = {};
  var prefixIris = [];
  for (var prefix in prefixes) {
    var iri = prefixes[prefix];
    if (isString(iri)) {
      this._prefixByIri[iri] = prefix;
      prefixIris.push(iri);
    }
  }
  var iriList = prefixIris.join('|').replace(/[\]\/\(\)\*\+\?\.\\\$]/g, '\\$&');
  this._prefixRegex = new RegExp('^(' + iriList + ')([a-zA-Z][\\-_a-zA-Z0-9]*)$');
  this._usedPrefixes = {};
  this._sparqlStar = options.sparqlStar;
  this._indent =  isString(options.indent)  ? options.indent  : '  ';
  this._newline = isString(options.newline) ? options.newline : '\n';
  this._explicitDatatype = Boolean(options.explicitDatatype);
}

// Converts the parsed query object into a SPARQL query
Generator.prototype.toQuery = function (q) {
  var query = '';

  if (q.queryType)
    query += q.queryType.toUpperCase() + ' ';
  if (q.reduced)
    query += 'REDUCED ';
  if (q.distinct)
    query += 'DISTINCT ';

  if (q.variables){
    query += mapJoin(q.variables, undefined, function (variable) {
      return isTerm(variable) ? this.toEntity(variable) :
             '(' + this.toExpression(variable.expression) + ' AS ' + variableToString(variable.variable) + ')';
    }, this) + ' ';
  }
  else if (q.template)
    query += this.group(q.template, true) + this._newline;

  if (q.from)
    query += this.graphs('FROM ', q.from.default) + this.graphs('FROM NAMED ', q.from.named);
  if (q.where)
    query += 'WHERE ' + this.group(q.where, true) + this._newline;

  if (q.updates)
    query += mapJoin(q.updates, ';' + this._newline, this.toUpdate, this);

  if (q.group)
    query += 'GROUP BY ' + mapJoin(q.group, undefined, function (it) {
      var result = isTerm(it.expression)
        ? this.toEntity(it.expression)
        : '(' + this.toExpression(it.expression) + ')';
      return it.variable ? '(' + result + ' AS ' + variableToString(it.variable) + ')' : result;
    }, this) + this._newline;
  if (q.having)
    query += 'HAVING (' + mapJoin(q.having, undefined, this.toExpression, this) + ')' + this._newline;
  if (q.order)
    query += 'ORDER BY ' + mapJoin(q.order, undefined, function (it) {
      var expr = '(' + this.toExpression(it.expression) + ')';
      return !it.descending ? expr : 'DESC ' + expr;
    }, this) + this._newline;

  if (q.offset)
    query += 'OFFSET ' + q.offset + this._newline;
  if (q.limit)
    query += 'LIMIT ' + q.limit + this._newline;

  if (q.values)
    query += this.values(q);

  // stringify prefixes at the end to mark used ones
  query = this.baseAndPrefixes(q) + query;
  return query.trim();
};

Generator.prototype.baseAndPrefixes = function (q) {
  var base = q.base ? ('BASE <' + q.base + '>' + this._newline) : '';
  var prefixes = '';
  for (var key in q.prefixes) {
    if (this._options.allPrefixes || this._usedPrefixes[key])
      prefixes += 'PREFIX ' + key + ': <' + q.prefixes[key] + '>' + this._newline;
  }
  return base + prefixes;
};

// Converts the parsed SPARQL pattern into a SPARQL pattern
Generator.prototype.toPattern = function (pattern) {
  var type = pattern.type || (pattern instanceof Array) && 'array' ||
             (pattern.subject && pattern.predicate && pattern.object ? 'triple' : '');
  if (!(type in this))
    throw new Error('Unknown entry type: ' + type);
  return this[type](pattern);
};

Generator.prototype.triple = function (t) {
  return this.toEntity(t.subject) + ' ' + this.toEntity(t.predicate) + ' ' + this.toEntity(t.object) + '.';
};

Generator.prototype.array = function (items) {
  return mapJoin(items, this._newline, this.toPattern, this);
};

Generator.prototype.bgp = function (bgp) {
  return this.encodeTriples(bgp.triples);
};

Generator.prototype.encodeTriples = function (triples) {
  if (!triples.length)
    return '';

  var parts = [], subject = undefined, predicate = undefined;
  for (var i = 0; i < triples.length; i++) {
    var triple = triples[i];
    // Triple with different subject
    if (!equalTerms(triple.subject, subject)) {
      // Terminate previous triple
      if (subject)
        parts.push('.' + this._newline);
      subject = triple.subject;
      predicate = triple.predicate;
      parts.push(this.toEntity(subject), ' ', this.toEntity(predicate));
    }
    // Triple with same subject but different predicate
    else if (!equalTerms(triple.predicate, predicate)) {
      predicate = triple.predicate;
      parts.push(';' + this._newline, this._indent, this.toEntity(predicate));
    }
    // Triple with same subject and predicate
    else {
      parts.push(',');
    }
    parts.push(' ', this.toEntity(triple.object));
  }
  parts.push('.');

  return parts.join('');
}

Generator.prototype.graph = function (graph) {
  return 'GRAPH ' + this.toEntity(graph.name) + ' ' + this.group(graph);
};

Generator.prototype.graphs = function (keyword, graphs) {
  return !graphs || graphs.length === 0 ? '' :
    mapJoin(graphs, '', function (g) { return keyword + this.toEntity(g) + this._newline; }, this)
}

Generator.prototype.group = function (group, inline) {
  group = inline !== true ? this.array(group.patterns || group.triples)
                          : this.toPattern(group.type !== 'group' ? group : group.patterns);
  return group.indexOf(this._newline) === -1 ? '{ ' + group + ' }' : '{' + this._newline + this.indent(group) + this._newline + '}';
};

Generator.prototype.query = function (query) {
  return this.toQuery(query);
};

Generator.prototype.filter = function (filter) {
  return 'FILTER(' + this.toExpression(filter.expression) + ')';
};

Generator.prototype.bind = function (bind) {
  return 'BIND(' + this.toExpression(bind.expression) + ' AS ' + variableToString(bind.variable) + ')';
};

Generator.prototype.optional = function (optional) {
  return 'OPTIONAL ' + this.group(optional);
};

Generator.prototype.union = function (union) {
  return mapJoin(union.patterns, this._newline + 'UNION' + this._newline, function (p) { return this.group(p, true); }, this);
};

Generator.prototype.minus = function (minus) {
  return 'MINUS ' + this.group(minus);
};

Generator.prototype.values = function (valuesList) {
  // Gather unique keys
  var keys = Object.keys(valuesList.values.reduce(function (keyHash, values) {
    for (var key in values) keyHash[key] = true;
    return keyHash;
  }, {}));
  // Check whether simple syntax can be used
  var lparen, rparen;
  if (keys.length === 1) {
    lparen = rparen = '';
  } else {
    lparen = '(';
    rparen = ')';
  }
  // Create value rows
  return 'VALUES ' + lparen + keys.join(' ') + rparen + ' {' + this._newline +
    mapJoin(valuesList.values, this._newline, function (values) {
      return '  ' + lparen + mapJoin(keys, undefined, function (key) {
        return values[key] ? this.toEntity(values[key]) : 'UNDEF';
      }, this) + rparen;
    }, this) + this._newline + '}';
};

Generator.prototype.service = function (service) {
  return 'SERVICE ' + (service.silent ? 'SILENT ' : '') + this.toEntity(service.name) + ' ' +
         this.group(service);
};

// Converts the parsed expression object into a SPARQL expression
Generator.prototype.toExpression = function (expr) {
  if (isTerm(expr)) {
    return this.toEntity(expr);
  }
  switch (expr.type.toLowerCase()) {
    case 'aggregate':
      return expr.aggregation.toUpperCase() +
             '(' + (expr.distinct ? 'DISTINCT ' : '') + this.toExpression(expr.expression) +
             (typeof expr.separator === 'string' ? '; SEPARATOR = ' + '"' + expr.separator.replace(escape, escapeReplacer) + '"' : '') + ')';
    case 'functioncall':
      return this.toEntity(expr.function) + '(' + mapJoin(expr.args, ', ', this.toExpression, this) + ')';
    case 'operation':
      var operator = expr.operator.toUpperCase(), args = expr.args || [];
      switch (expr.operator.toLowerCase()) {
      // Infix operators
      case '<':
      case '>':
      case '>=':
      case '<=':
      case '&&':
      case '||':
      case '=':
      case '!=':
      case '+':
      case '-':
      case '*':
      case '/':
          return (isTerm(args[0]) ? this.toEntity(args[0]) : '(' + this.toExpression(args[0]) + ')') +
                 ' ' + operator + ' ' +
                 (isTerm(args[1]) ? this.toEntity(args[1]) : '(' + this.toExpression(args[1]) + ')');
      // Unary operators
      case '!':
        return '!(' + this.toExpression(args[0]) + ')';
      case 'uplus':
        return '+(' + this.toExpression(args[0]) + ')';
      case 'uminus':
        return '-(' + this.toExpression(args[0]) + ')';
      // IN and NOT IN
      case 'notin':
        operator = 'NOT IN';
      case 'in':
        return this.toExpression(args[0]) + ' ' + operator +
               '(' + (isString(args[1]) ? args[1] : mapJoin(args[1], ', ', this.toExpression, this)) + ')';
      // EXISTS and NOT EXISTS
      case 'notexists':
        operator = 'NOT EXISTS';
      case 'exists':
        return operator + ' ' + this.group(args[0], true);
      // Other expressions
      default:
        return operator + '(' + mapJoin(args, ', ', this.toExpression, this) + ')';
      }
    default:
      throw new Error('Unknown expression type: ' + expr.type);
  }
};

// Converts the parsed entity (or property path) into a SPARQL entity
Generator.prototype.toEntity = function (value) {
  if (isTerm(value)) {
    switch (value.termType) {
    // variable, * selector, or blank node
    case 'Wildcard':
      return '*';
    case 'Variable':
      return variableToString(value);
    case 'BlankNode':
      return '_:' + value.value;
    // literal
    case 'Literal':
      var lexical = value.value || '', language = value.language || '', datatype = value.datatype;
      value = '"' + lexical.replace(escape, escapeReplacer) + '"';
      if (language){
        value += '@' + language;
      } else if (datatype) {
        // Abbreviate literals when possible
        if (!this._explicitDatatype) {
          switch (datatype.value) {
          case XSD_STRING:
            return value;
          case XSD_INTEGER:
            if (/^\d+$/.test(lexical))
              // Add space to avoid confusion with decimals in broken parsers
              return lexical + ' ';
          }
        }
        value += '^^' + this.encodeIRI(datatype.value);
      }
      return value;
    case 'Quad':
      if (!this._sparqlStar)
          throw new Error('SPARQL* support is not enabled');

      if (value.graph && value.graph.termType !== "DefaultGraph") {
        return '<< GRAPH ' +
          this.toEntity(value.graph) +
          ' { ' +
          this.toEntity(value.subject) + ' ' +
          this.toEntity(value.predicate) + ' ' +
          this.toEntity(value.object) +
          ' } ' +
          ' >>'
      }
      else {
        return (
          '<< ' +
          this.toEntity(value.subject) + ' ' +
          this.toEntity(value.predicate) + ' ' +
          this.toEntity(value.object) +
          ' >>'
        );
      }
    // IRI
    default:
      return this.encodeIRI(value.value);
    }
  }
  // property path
  else {
    var items = value.items.map(this.toEntity, this), path = value.pathType;
    switch (path) {
    // prefix operator
    case '^':
    case '!':
      return path + items[0];
    // postfix operator
    case '*':
    case '+':
    case '?':
      return '(' + items[0] + path + ')';
    // infix operator
    default:
      return '(' + items.join(path) + ')';
    }
  }
};
var escape = /["\\\t\n\r\b\f]/g,
    escapeReplacer = function (c) { return escapeReplacements[c]; },
    escapeReplacements = { '\\': '\\\\', '"': '\\"', '\t': '\\t',
                           '\n': '\\n', '\r': '\\r', '\b': '\\b', '\f': '\\f' };

// Represent the IRI, as a prefixed name when possible
Generator.prototype.encodeIRI = function (iri) {
  var prefixMatch = this._prefixRegex.exec(iri);
  if (prefixMatch) {
    var prefix = this._prefixByIri[prefixMatch[1]];
    this._usedPrefixes[prefix] = true;
    return prefix + ':' + prefixMatch[2];
  }
  return '<' + iri + '>';
};

// Converts the parsed update object into a SPARQL update clause
Generator.prototype.toUpdate = function (update) {
  switch (update.type || update.updateType) {
  case 'load':
    return 'LOAD' + (update.source ? ' ' + this.toEntity(update.source) : '') +
           (update.destination ? ' INTO GRAPH ' + this.toEntity(update.destination) : '');
  case 'insert':
    return 'INSERT DATA '  + this.group(update.insert, true);
  case 'delete':
    return 'DELETE DATA '  + this.group(update.delete, true);
  case 'deletewhere':
    return 'DELETE WHERE ' + this.group(update.delete, true);
  case 'insertdelete':
    return (update.graph ? 'WITH ' + this.toEntity(update.graph) + this._newline : '') +
           (update.delete.length ? 'DELETE ' + this.group(update.delete, true) + this._newline : '') +
           (update.insert.length ? 'INSERT ' + this.group(update.insert, true) + this._newline : '') +
           (update.using ? this.graphs('USING ', update.using.default) : '') +
           (update.using ? this.graphs('USING NAMED ', update.using.named) : '') +
           'WHERE ' + this.group(update.where, true);
  case 'add':
  case 'copy':
  case 'move':
    return update.type.toUpperCase()+ ' ' +  (update.silent ? 'SILENT ' : '') + (update.source.default ? 'DEFAULT' : this.toEntity(update.source.name)) +
           ' TO ' + this.toEntity(update.destination.name);
  case 'create':
  case 'clear':
  case 'drop':
    return update.type.toUpperCase() + (update.silent ? ' SILENT ' : ' ') + (
      update.graph.default ? 'DEFAULT' :
      update.graph.named ? 'NAMED' :
      update.graph.all ? 'ALL' :
      ('GRAPH ' + this.toEntity(update.graph.name))
    );
  default:
    throw new Error('Unknown update query type: ' + update.type);
  }
};

// Indents each line of the string
Generator.prototype.indent = function(text) { return text.replace(/^/gm, this._indent); }

function variableToString(variable){
  return '?' + variable.value;
}

// Checks whether the object is a string
function isString(object) { return typeof object === 'string'; }

// Checks whether the object is a Term
function isTerm(object) {
  return typeof object.termType === 'string';
}

// Checks whether term1 and term2 are equivalent without `.equals()` prototype method
function equalTerms(term1, term2) {
  if (!term1 || !isTerm(term1)) { return false; }
  if (!term2 || !isTerm(term2)) { return false; }
  if (term1.termType !== term2.termType) { return false; }
  switch (term1.termType) {
    case 'Literal':
      return term1.value === term2.value
          && term1.language === term2.language
          && equalTerms(term1.datatype, term2.datatype);
    case 'Quad':
      return equalTerms(term1.subject, term2.subject)
          && equalTerms(term1.predicate, term2.predicate)
          && equalTerms(term1.object, term2.object)
          && equalTerms(term1.graph, term2.graph);
    default:
      return term1.value === term2.value;
  }
}

// Maps the array with the given function, and joins the results using the separator
function mapJoin(array, sep, func, self) {
  return array.map(func, self).join(isString(sep) ? sep : ' ');
}

/**
 * @param options {
 *   allPrefixes: boolean,
 *   indentation: string,
 *   newline: string
 * }
 */
module.exports = function SparqlGenerator(options = {}) {
  return {
    stringify: function (query) {
      var currentOptions = Object.create(options);
      currentOptions.prefixes = query.prefixes;
      return new Generator(currentOptions).toQuery(query);
    },
    createGenerator: function() { return new Generator(options); }
  };
};


/***/ }),

/***/ 5131:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(80292);
/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var SparqlParser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[6,12,13,15,16,28,35,41,50,55,107,117,120,122,123,132,133,138,195,219,224,312,322,323,324,325,326],$V1=[2,211],$V2=[107,117,120,122,123,132,133,138,322,323,324,325,326],$V3=[2,389],$V4=[1,22],$V5=[1,31],$V6=[13,16,35,195,219,224,312],$V7=[6,90],$V8=[45,46,58],$V9=[45,58],$Va=[1,62],$Vb=[1,64],$Vc=[1,60],$Vd=[1,63],$Ve=[1,69],$Vf=[1,70],$Vg=[26,34,35],$Vh=[13,16,35,195,219,312],$Vi=[13,16,312],$Vj=[119,141,320,327],$Vk=[13,16,119,141,312],$Vl=[1,96],$Vm=[1,100],$Vn=[1,102],$Vo=[119,141,320,321,327],$Vp=[13,16,119,141,312,321],$Vq=[1,108],$Vr=[2,253],$Vs=[1,107],$Vt=[13,16,34,35,87,93,226,231,245,246,299,300,301,302,303,304,305,306,307,308,309,310,311,312],$Vu=[6,45,46,58,68,75,78,86,88,90],$Vv=[6,13,16,34,45,46,58,68,75,78,86,88,90,312],$Vw=[6,13,16,26,34,35,37,38,45,46,48,58,68,75,78,86,87,88,90,93,100,116,119,132,133,135,140,167,168,170,173,174,191,195,219,224,226,227,231,235,245,246,250,254,258,271,273,278,295,299,300,301,302,303,304,305,306,307,308,309,310,311,312,328,330,331,333,334,335,336,337,338,339],$Vx=[34,35,45,46,58],$Vy=[1,139],$Vz=[1,140],$VA=[1,151],$VB=[1,131],$VC=[1,125],$VD=[1,130],$VE=[1,132],$VF=[1,142],$VG=[1,143],$VH=[1,144],$VI=[1,145],$VJ=[1,147],$VK=[1,148],$VL=[2,461],$VM=[1,157],$VN=[1,158],$VO=[1,159],$VP=[1,152],$VQ=[1,153],$VR=[1,156],$VS=[1,166],$VT=[1,167],$VU=[1,168],$VV=[1,169],$VW=[1,170],$VX=[1,171],$VY=[1,172],$VZ=[1,173],$V_=[1,174],$V$=[1,175],$V01=[1,165],$V11=[1,160],$V21=[1,161],$V31=[1,162],$V41=[1,163],$V51=[1,164],$V61=[6,13,16,34,35,46,48,87,90,93,119,167,168,170,173,174,226,231,245,246,299,300,301,302,303,304,305,306,307,308,309,310,311,312,328],$V71=[2,312],$V81=[1,199],$V91=[1,197],$Va1=[6,191],$Vb1=[2,329],$Vc1=[2,317],$Vd1=[45,135],$Ve1=[6,48,78,86,88,90],$Vf1=[2,257],$Vg1=[1,213],$Vh1=[1,215],$Vi1=[6,48,75,78,86,88,90],$Vj1=[2,255],$Vk1=[1,221],$Vl1=[1,233],$Vm1=[1,231],$Vn1=[1,239],$Vo1=[1,232],$Vp1=[1,237],$Vq1=[1,238],$Vr1=[6,68,75,78,86,88,90],$Vs1=[37,38,191,250,278],$Vt1=[37,38,191,250,254,278],$Vu1=[37,38,191,250,254,258,271,273,278,295,306,307,308,309,310,311,334,335,336,337,338,339],$Vv1=[26,37,38,191,250,254,258,271,273,278,295,306,307,308,309,310,311,331,334,335,336,337,338,339],$Vw1=[1,267],$Vx1=[1,266],$Vy1=[6,13,16,26,34,35,37,38,46,48,75,78,81,83,86,87,88,90,93,119,167,168,170,173,174,191,226,231,245,246,250,254,258,271,273,275,276,277,278,279,281,282,284,285,288,290,295,299,300,301,302,303,304,305,306,307,308,309,310,311,312,328,331,334,335,336,337,338,339,340,341,342,343,344],$Vz1=[1,275],$VA1=[1,274],$VB1=[13,16,26,34,35,37,38,46,48,87,90,93,100,119,167,168,170,173,174,191,195,219,224,226,227,231,235,245,246,250,254,258,271,273,278,295,299,300,301,302,303,304,305,306,307,308,309,310,311,312,328,331,334,335,336,337,338,339],$VC1=[35,93],$VD1=[13,16,26,34,35,37,38,46,48,87,90,93,100,119,167,168,170,173,174,191,195,219,224,226,227,231,235,245,246,250,254,258,271,273,278,295,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,328,331,334,335,336,337,338,339],$VE1=[13,16,48,87,100,231,299,300,301,302,303,304,305,306,307,308,309,310,311,312],$VF1=[48,93],$VG1=[34,38],$VH1=[6,13,16,34,35,38,87,93,226,231,245,246,299,300,301,302,303,304,305,306,307,308,309,310,311,312,330,331],$VI1=[6,13,16,26,34,35,38,87,93,226,231,245,246,271,299,300,301,302,303,304,305,306,307,308,309,310,311,312,330,331,333],$VJ1=[1,299],$VK1=[1,300],$VL1=[6,116,191],$VM1=[48,119],$VN1=[6,48,86,88,90],$VO1=[2,341],$VP1=[2,333],$VQ1=[1,340],$VR1=[1,342],$VS1=[48,119,328],$VT1=[13,16,34,195,312],$VU1=[13,16,34,35,38,46,48,87,90,93,119,167,168,170,173,174,191,195,219,224,226,227,231,235,245,246,278,299,300,301,302,303,304,305,306,307,308,309,310,311,312,328],$VV1=[13,16,34,35,87,219,271,273,275,276,277,279,281,282,284,285,288,290,299,300,301,302,303,304,305,306,307,308,309,310,311,312,339,340,341,342,343,344],$VW1=[1,374],$VX1=[1,375],$VY1=[13,16,26,34,35,87,219,271,273,275,276,277,279,281,282,284,285,288,290,299,300,301,302,303,304,305,306,307,308,309,310,311,312,339,340,341,342,343,344],$VZ1=[1,398],$V_1=[1,399],$V$1=[13,16,38,195,224,312],$V02=[1,416],$V12=[6,48,90],$V22=[6,13,16,35,48,78,86,88,90,275,276,277,279,281,282,284,285,288,290,312,339,340,341,342,343,344],$V32=[6,13,16,34,35,46,48,78,81,83,86,87,88,90,93,119,167,168,170,173,174,226,231,245,246,275,276,277,279,281,282,284,285,288,290,299,300,301,302,303,304,305,306,307,308,309,310,311,312,328,339,340,341,342,343,344],$V42=[46,48,90,119,167,168,170,173,174],$V52=[1,435],$V62=[1,436],$V72=[1,442],$V82=[1,441],$V92=[48,119,191,227,328],$Va2=[13,16,34,35,38,87,93,226,231,245,246,299,300,301,302,303,304,305,306,307,308,309,310,311,312],$Vb2=[13,16,34,35,38,48,87,93,119,191,226,227,231,245,246,278,299,300,301,302,303,304,305,306,307,308,309,310,311,312,328],$Vc2=[13,16,38,48,87,100,231,299,300,301,302,303,304,305,306,307,308,309,310,311,312],$Vd2=[35,48],$Ve2=[2,332],$Vf2=[1,497],$Vg2=[1,494],$Vh2=[1,495],$Vi2=[6,13,16,26,34,35,37,38,46,48,68,75,78,81,83,86,87,88,90,93,119,167,168,170,173,174,191,226,231,245,246,250,254,258,271,273,275,276,277,278,279,281,282,284,285,288,290,295,299,300,301,302,303,304,305,306,307,308,309,310,311,312,328,329,331,334,335,336,337,338,339,340,341,342,343,344],$Vj2=[1,515],$Vk2=[46,48,90,119,167,168,170,173,174,328],$Vl2=[13,16,34,35,195,219,224,312],$Vm2=[6,13,16,34,35,48,75,78,86,88,90,275,276,277,279,281,282,284,285,288,290,312,339,340,341,342,343,344],$Vn2=[13,16,34,35,38,48,87,93,119,191,195,226,227,231,245,246,278,299,300,301,302,303,304,305,306,307,308,309,310,311,312,328],$Vo2=[6,13,16,34,35,48,81,83,86,88,90,275,276,277,279,281,282,284,285,288,290,312,339,340,341,342,343,344],$Vp2=[13,16,34,35,46,48,87,90,93,119,167,168,170,173,174,226,231,245,246,299,300,301,302,303,304,305,306,307,308,309,310,311,312],$Vq2=[13,16,34,312],$Vr2=[13,16,34,35,46,48,87,90,93,119,167,168,170,173,174,226,231,245,246,299,300,301,302,303,304,305,306,307,308,309,310,311,312,328],$Vs2=[2,344],$Vt2=[13,16,34,35,38,46,48,87,90,93,119,167,168,170,173,174,191,226,227,231,245,246,278,299,300,301,302,303,304,305,306,307,308,309,310,311,312,328],$Vu2=[13,16,34,35,37,38,46,48,87,90,93,119,167,168,170,173,174,191,195,219,224,226,227,231,235,245,246,278,299,300,301,302,303,304,305,306,307,308,309,310,311,312,328],$Vv2=[2,339],$Vw2=[13,16,34,35,38,46,48,87,90,93,119,167,168,170,173,174,191,195,219,224,226,227,231,245,246,278,299,300,301,302,303,304,305,306,307,308,309,310,311,312,328],$Vx2=[13,16,38,87,100,231,299,300,301,302,303,304,305,306,307,308,309,310,311,312],$Vy2=[46,48,90,119,167,168,170,173,174,191,227,328],$Vz2=[13,16,34,38,48,87,100,195,231,235,299,300,301,302,303,304,305,306,307,308,309,310,311,312],$VA2=[13,16,34,35,48,87,93,119,226,231,245,246,299,300,301,302,303,304,305,306,307,308,309,310,311,312],$VB2=[2,327];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"QueryOrUpdate":3,"Prologue":4,"QueryOrUpdate_group0":5,"EOF":6,"Prologue_repetition0":7,"Query":8,"Query_group0":9,"Query_option0":10,"BaseDecl":11,"BASE":12,"IRIREF":13,"PrefixDecl":14,"PREFIX":15,"PNAME_NS":16,"SelectQuery":17,"SelectClauseWildcard":18,"SelectQuery_repetition0":19,"WhereClause":20,"SolutionModifierNoGroup":21,"SelectClauseVars":22,"SelectQuery_repetition1":23,"SolutionModifier":24,"SelectClauseBase":25,"*":26,"SelectClauseVars_repetition_plus0":27,"SELECT":28,"SelectClauseBase_option0":29,"SubSelect":30,"SubSelect_option0":31,"SubSelect_option1":32,"SelectClauseItem":33,"VAR":34,"(":35,"Expression":36,"AS":37,")":38,"VarTriple":39,"ConstructQuery":40,"CONSTRUCT":41,"ConstructTemplate":42,"ConstructQuery_repetition0":43,"ConstructQuery_repetition1":44,"WHERE":45,"{":46,"ConstructQuery_option0":47,"}":48,"DescribeQuery":49,"DESCRIBE":50,"DescribeQuery_group0":51,"DescribeQuery_repetition0":52,"DescribeQuery_option0":53,"AskQuery":54,"ASK":55,"AskQuery_repetition0":56,"DatasetClause":57,"FROM":58,"DatasetClause_option0":59,"iri":60,"WhereClause_option0":61,"GroupGraphPattern":62,"SolutionModifier_option0":63,"SolutionModifierNoGroup_option0":64,"SolutionModifierNoGroup_option1":65,"SolutionModifierNoGroup_option2":66,"GroupClause":67,"GROUP":68,"BY":69,"GroupClause_repetition_plus0":70,"GroupCondition":71,"BuiltInCall":72,"FunctionCall":73,"HavingClause":74,"HAVING":75,"HavingClause_repetition_plus0":76,"OrderClause":77,"ORDER":78,"OrderClause_repetition_plus0":79,"OrderCondition":80,"ASC":81,"BrackettedExpression":82,"DESC":83,"Constraint":84,"LimitOffsetClauses":85,"LIMIT":86,"INTEGER":87,"OFFSET":88,"ValuesClause":89,"VALUES":90,"InlineData":91,"InlineData_repetition0":92,"NIL":93,"InlineData_repetition1":94,"InlineData_repetition_plus2":95,"InlineData_repetition3":96,"DataBlockValue":97,"Literal":98,"ConstTriple":99,"UNDEF":100,"DataBlockValueList":101,"DataBlockValueList_repetition_plus0":102,"Update":103,"Update_repetition0":104,"Update1":105,"Update_option0":106,"LOAD":107,"Update1_option0":108,"Update1_option1":109,"Update1_group0":110,"Update1_option2":111,"GraphRefAll":112,"Update1_group1":113,"Update1_option3":114,"GraphOrDefault":115,"TO":116,"CREATE":117,"Update1_option4":118,"GRAPH":119,"INSERTDATA":120,"QuadPattern":121,"DELETEDATA":122,"DELETEWHERE":123,"Update1_option5":124,"InsertClause":125,"Update1_option6":126,"Update1_repetition0":127,"Update1_option7":128,"DeleteClause":129,"Update1_option8":130,"Update1_repetition1":131,"DELETE":132,"INSERT":133,"UsingClause":134,"USING":135,"UsingClause_option0":136,"WithClause":137,"WITH":138,"IntoGraphClause":139,"INTO":140,"DEFAULT":141,"GraphOrDefault_option0":142,"GraphRefAll_group0":143,"QuadPattern_option0":144,"QuadPattern_repetition0":145,"QuadsNotTriples":146,"QuadsNotTriples_group0":147,"QuadsNotTriples_option0":148,"QuadsNotTriples_option1":149,"QuadsNotTriples_option2":150,"TriplesTemplate":151,"TriplesTemplate_repetition0":152,"TriplesSameSubject":153,"TriplesTemplate_option0":154,"GroupGraphPatternSub":155,"GroupGraphPatternSub_option0":156,"GroupGraphPatternSub_repetition0":157,"GroupGraphPatternSubTail":158,"GraphPatternNotTriples":159,"GroupGraphPatternSubTail_option0":160,"GroupGraphPatternSubTail_option1":161,"TriplesBlock":162,"TriplesBlock_repetition0":163,"TriplesSameSubjectPath":164,"TriplesBlock_option0":165,"GraphPatternNotTriples_repetition0":166,"OPTIONAL":167,"MINUS":168,"GraphPatternNotTriples_group0":169,"SERVICE":170,"GraphPatternNotTriples_option0":171,"GraphPatternNotTriples_group1":172,"FILTER":173,"BIND":174,"FunctionCall_option0":175,"FunctionCall_repetition0":176,"ExpressionList":177,"ExpressionList_repetition0":178,"ConstructTemplate_option0":179,"ConstructTriples":180,"ConstructTriples_repetition0":181,"ConstructTriples_option0":182,"TriplesSameSubject_group0":183,"PropertyListNotEmpty":184,"TriplesNode":185,"PropertyList":186,"PropertyList_option0":187,"VerbObjectList":188,"PropertyListNotEmpty_repetition0":189,"SemiOptionalVerbObjectList":190,";":191,"SemiOptionalVerbObjectList_option0":192,"Verb":193,"ObjectList":194,"a":195,"ObjectList_repetition0":196,"GraphNode":197,"ObjectListPath":198,"ObjectListPath_repetition0":199,"GraphNodePath":200,"TriplesSameSubjectPath_group0":201,"PropertyListPathNotEmpty":202,"TriplesNodePath":203,"TriplesSameSubjectPath_option0":204,"PropertyListPathNotEmpty_group0":205,"PropertyListPathNotEmpty_repetition0":206,"PropertyListPathNotEmpty_repetition1":207,"PropertyListPathNotEmptyTail":208,"PropertyListPathNotEmptyTail_group0":209,"Path":210,"Path_repetition0":211,"PathSequence":212,"PathSequence_repetition0":213,"PathEltOrInverse":214,"PathElt":215,"PathPrimary":216,"PathElt_option0":217,"PathEltOrInverse_option0":218,"!":219,"PathNegatedPropertySet":220,"PathOneInPropertySet":221,"PathNegatedPropertySet_repetition0":222,"PathNegatedPropertySet_option0":223,"^":224,"TriplesNode_repetition_plus0":225,"[":226,"]":227,"TriplesNodePath_repetition_plus0":228,"GraphNode_group0":229,"GraphNodePath_group0":230,"<<":231,"VarTriple_group0":232,"VarTriple_group1":233,"VarTriple_group2":234,">>":235,"VarTriple_group3":236,"VarTriple_group4":237,"ConstTriple_group0":238,"ConstTriple_group1":239,"ConstTriple_group2":240,"ConstTriple_group3":241,"ConstTriple_group4":242,"VarOrTerm":243,"Term":244,"BLANK_NODE_LABEL":245,"ANON":246,"ConditionalAndExpression":247,"Expression_repetition0":248,"ExpressionTail":249,"||":250,"RelationalExpression":251,"ConditionalAndExpression_repetition0":252,"ConditionalAndExpressionTail":253,"&&":254,"AdditiveExpression":255,"RelationalExpression_group0":256,"RelationalExpression_option0":257,"IN":258,"MultiplicativeExpression":259,"AdditiveExpression_repetition0":260,"AdditiveExpressionTail":261,"AdditiveExpressionTail_group0":262,"NumericLiteralPositive":263,"AdditiveExpressionTail_repetition0":264,"NumericLiteralNegative":265,"AdditiveExpressionTail_repetition1":266,"UnaryExpression":267,"MultiplicativeExpression_repetition0":268,"MultiplicativeExpressionTail":269,"MultiplicativeExpressionTail_group0":270,"+":271,"PrimaryExpression":272,"-":273,"Aggregate":274,"FUNC_ARITY0":275,"FUNC_ARITY1":276,"FUNC_ARITY2":277,",":278,"IF":279,"BuiltInCall_group0":280,"BOUND":281,"BNODE":282,"BuiltInCall_option0":283,"EXISTS":284,"COUNT":285,"Aggregate_option0":286,"Aggregate_group0":287,"FUNC_AGGREGATE":288,"Aggregate_option1":289,"GROUP_CONCAT":290,"Aggregate_option2":291,"Aggregate_option3":292,"GroupConcatSeparator":293,"SEPARATOR":294,"=":295,"String":296,"LANGTAG":297,"^^":298,"DECIMAL":299,"DOUBLE":300,"BOOLEAN":301,"STRING_LITERAL1":302,"STRING_LITERAL2":303,"STRING_LITERAL_LONG1":304,"STRING_LITERAL_LONG2":305,"INTEGER_POSITIVE":306,"DECIMAL_POSITIVE":307,"DOUBLE_POSITIVE":308,"INTEGER_NEGATIVE":309,"DECIMAL_NEGATIVE":310,"DOUBLE_NEGATIVE":311,"PNAME_LN":312,"QueryOrUpdate_group0_option0":313,"Prologue_repetition0_group0":314,"SelectClauseBase_option0_group0":315,"DISTINCT":316,"REDUCED":317,"DescribeQuery_group0_repetition_plus0_group0":318,"DescribeQuery_group0_repetition_plus0":319,"NAMED":320,"SILENT":321,"CLEAR":322,"DROP":323,"ADD":324,"MOVE":325,"COPY":326,"ALL":327,".":328,"UNION":329,"|":330,"/":331,"PathElt_option0_group0":332,"?":333,"!=":334,"<":335,">":336,"<=":337,">=":338,"NOT":339,"CONCAT":340,"COALESCE":341,"SUBSTR":342,"REGEX":343,"REPLACE":344,"$accept":0,"$end":1},
terminals_: {2:"error",6:"EOF",12:"BASE",13:"IRIREF",15:"PREFIX",16:"PNAME_NS",26:"*",28:"SELECT",34:"VAR",35:"(",37:"AS",38:")",41:"CONSTRUCT",45:"WHERE",46:"{",48:"}",50:"DESCRIBE",55:"ASK",58:"FROM",68:"GROUP",69:"BY",75:"HAVING",78:"ORDER",81:"ASC",83:"DESC",86:"LIMIT",87:"INTEGER",88:"OFFSET",90:"VALUES",93:"NIL",100:"UNDEF",107:"LOAD",116:"TO",117:"CREATE",119:"GRAPH",120:"INSERTDATA",122:"DELETEDATA",123:"DELETEWHERE",132:"DELETE",133:"INSERT",135:"USING",138:"WITH",140:"INTO",141:"DEFAULT",167:"OPTIONAL",168:"MINUS",170:"SERVICE",173:"FILTER",174:"BIND",191:";",195:"a",219:"!",224:"^",226:"[",227:"]",231:"<<",235:">>",245:"BLANK_NODE_LABEL",246:"ANON",250:"||",254:"&&",258:"IN",271:"+",273:"-",275:"FUNC_ARITY0",276:"FUNC_ARITY1",277:"FUNC_ARITY2",278:",",279:"IF",281:"BOUND",282:"BNODE",284:"EXISTS",285:"COUNT",288:"FUNC_AGGREGATE",290:"GROUP_CONCAT",294:"SEPARATOR",295:"=",297:"LANGTAG",298:"^^",299:"DECIMAL",300:"DOUBLE",301:"BOOLEAN",302:"STRING_LITERAL1",303:"STRING_LITERAL2",304:"STRING_LITERAL_LONG1",305:"STRING_LITERAL_LONG2",306:"INTEGER_POSITIVE",307:"DECIMAL_POSITIVE",308:"DOUBLE_POSITIVE",309:"INTEGER_NEGATIVE",310:"DECIMAL_NEGATIVE",311:"DOUBLE_NEGATIVE",312:"PNAME_LN",316:"DISTINCT",317:"REDUCED",320:"NAMED",321:"SILENT",322:"CLEAR",323:"DROP",324:"ADD",325:"MOVE",326:"COPY",327:"ALL",328:".",329:"UNION",330:"|",331:"/",333:"?",334:"!=",335:"<",336:">",337:"<=",338:">=",339:"NOT",340:"CONCAT",341:"COALESCE",342:"SUBSTR",343:"REGEX",344:"REPLACE"},
productions_: [0,[3,3],[4,1],[8,2],[11,2],[14,3],[17,4],[17,4],[18,2],[22,2],[25,2],[30,4],[30,4],[33,1],[33,5],[33,5],[40,5],[40,7],[49,5],[54,4],[57,3],[20,2],[24,2],[21,3],[67,3],[71,1],[71,1],[71,3],[71,5],[71,1],[74,2],[77,3],[80,2],[80,2],[80,1],[80,1],[85,2],[85,2],[85,4],[85,4],[89,2],[91,4],[91,4],[91,6],[97,1],[97,1],[97,1],[97,1],[101,3],[103,3],[105,4],[105,3],[105,5],[105,4],[105,2],[105,2],[105,2],[105,6],[105,6],[129,2],[125,2],[134,3],[137,2],[139,3],[115,1],[115,2],[112,2],[112,1],[121,4],[146,7],[151,3],[62,3],[62,3],[155,2],[158,3],[162,3],[159,2],[159,2],[159,2],[159,3],[159,4],[159,2],[159,6],[159,6],[159,1],[84,1],[84,1],[84,1],[73,2],[73,6],[177,1],[177,4],[42,3],[180,3],[153,2],[153,2],[186,1],[184,2],[190,2],[188,2],[193,1],[193,1],[193,1],[194,2],[198,2],[164,2],[164,2],[202,4],[208,1],[208,3],[210,2],[212,2],[215,2],[214,2],[216,1],[216,1],[216,2],[216,3],[220,1],[220,1],[220,4],[221,1],[221,1],[221,2],[221,2],[185,3],[185,3],[203,3],[203,3],[197,1],[197,1],[200,1],[200,1],[39,9],[39,5],[99,9],[99,5],[243,1],[243,1],[244,1],[244,1],[244,1],[244,1],[244,1],[36,2],[249,2],[247,2],[253,2],[251,1],[251,3],[251,4],[255,2],[261,2],[261,2],[261,2],[259,2],[269,2],[267,2],[267,2],[267,2],[267,1],[272,1],[272,1],[272,1],[272,1],[272,1],[272,1],[82,3],[72,1],[72,2],[72,4],[72,6],[72,8],[72,2],[72,4],[72,2],[72,4],[72,3],[274,5],[274,5],[274,6],[293,4],[98,1],[98,2],[98,3],[98,1],[98,1],[98,1],[98,1],[98,1],[98,1],[296,1],[296,1],[296,1],[296,1],[263,1],[263,1],[263,1],[265,1],[265,1],[265,1],[60,1],[60,1],[60,1],[313,0],[313,1],[5,1],[5,1],[5,1],[314,1],[314,1],[7,0],[7,2],[9,1],[9,1],[9,1],[9,1],[10,0],[10,1],[19,0],[19,2],[23,0],[23,2],[27,1],[27,2],[315,1],[315,1],[29,0],[29,1],[31,0],[31,1],[32,0],[32,1],[43,0],[43,2],[44,0],[44,2],[47,0],[47,1],[318,1],[318,1],[319,1],[319,2],[51,1],[51,1],[52,0],[52,2],[53,0],[53,1],[56,0],[56,2],[59,0],[59,1],[61,0],[61,1],[63,0],[63,1],[64,0],[64,1],[65,0],[65,1],[66,0],[66,1],[70,1],[70,2],[76,1],[76,2],[79,1],[79,2],[92,0],[92,2],[94,0],[94,2],[95,1],[95,2],[96,0],[96,2],[102,1],[102,2],[104,0],[104,4],[106,0],[106,2],[108,0],[108,1],[109,0],[109,1],[110,1],[110,1],[111,0],[111,1],[113,1],[113,1],[113,1],[114,0],[114,1],[118,0],[118,1],[124,0],[124,1],[126,0],[126,1],[127,0],[127,2],[128,0],[128,1],[130,0],[130,1],[131,0],[131,2],[136,0],[136,1],[142,0],[142,1],[143,1],[143,1],[143,1],[144,0],[144,1],[145,0],[145,2],[147,1],[147,1],[148,0],[148,1],[149,0],[149,1],[150,0],[150,1],[152,0],[152,3],[154,0],[154,1],[156,0],[156,1],[157,0],[157,2],[160,0],[160,1],[161,0],[161,1],[163,0],[163,3],[165,0],[165,1],[166,0],[166,3],[169,1],[169,1],[171,0],[171,1],[172,1],[172,1],[175,0],[175,1],[176,0],[176,3],[178,0],[178,3],[179,0],[179,1],[181,0],[181,3],[182,0],[182,1],[183,1],[183,1],[187,0],[187,1],[189,0],[189,2],[192,0],[192,1],[196,0],[196,3],[199,0],[199,3],[201,1],[201,1],[204,0],[204,1],[205,1],[205,1],[206,0],[206,3],[207,0],[207,2],[209,1],[209,1],[211,0],[211,3],[213,0],[213,3],[332,1],[332,1],[332,1],[217,0],[217,1],[218,0],[218,1],[222,0],[222,3],[223,0],[223,1],[225,1],[225,2],[228,1],[228,2],[229,1],[229,1],[230,1],[230,1],[232,1],[232,1],[233,1],[233,1],[234,1],[234,1],[236,1],[236,1],[237,1],[237,1],[238,1],[238,1],[239,1],[239,1],[240,1],[240,1],[241,1],[241,1],[242,1],[242,1],[248,0],[248,2],[252,0],[252,2],[256,1],[256,1],[256,1],[256,1],[256,1],[256,1],[257,0],[257,1],[260,0],[260,2],[262,1],[262,1],[264,0],[264,2],[266,0],[266,2],[268,0],[268,2],[270,1],[270,1],[280,1],[280,1],[280,1],[280,1],[280,1],[283,0],[283,1],[286,0],[286,1],[287,1],[287,1],[289,0],[289,1],[291,0],[291,1],[292,0],[292,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:

      // Set parser options
      $$[$0-1] = $$[$0-1] || {};
      if (Parser.base)
        $$[$0-1].base = Parser.base;
      Parser.base = '';
      $$[$0-1].prefixes = Parser.prefixes;
      Parser.prefixes = null;

      if (Parser.pathOnly) {
        if ($$[$0-1].type === 'path' || 'termType' in $$[$0-1]) {
          return $$[$0-1]
        }
        throw new Error('Received full SPARQL query in path only mode');
      } else if ($$[$0-1].type === 'path' || 'termType' in $$[$0-1]) {
        throw new Error('Received only path in full SPARQL mode');
      }

      // Ensure that blank nodes are not used across INSERT DATA clauses
      if ($$[$0-1].type === 'update') {
        const insertBnodesAll = {};
        for (const update of $$[$0-1].updates) {
          if (update.updateType === 'insert') {
            // Collect bnodes for current insert clause
            const insertBnodes = {};
            for (const operation of update.insert) {
              if (operation.type === 'bgp' || operation.type === 'graph') {
                for (const triple of operation.triples) {
                  if (triple.subject.termType === 'BlankNode')
                    insertBnodes[triple.subject.value] = true;
                  if (triple.predicate.termType === 'BlankNode')
                    insertBnodes[triple.predicate.value] = true;
                  if (triple.object.termType === 'BlankNode')
                    insertBnodes[triple.object.value] = true;
                }
              }
            }

            // Check if the inserting bnodes don't clash with bnodes from a previous insert clause
            for (const bnode of Object.keys(insertBnodes)) {
              if (insertBnodesAll[bnode]) {
                throw new Error('Detected reuse blank node across different INSERT DATA clauses');
              }
              insertBnodesAll[bnode] = true;
            }
          }
        }
      }
      return $$[$0-1];
    
break;
case 3:
this.$ = extend($$[$0-1], $$[$0], { type: 'query' });
break;
case 4:

      Parser.base = resolveIRI($$[$0])
    
break;
case 5:

      if (!Parser.prefixes) Parser.prefixes = {};
      $$[$0-1] = $$[$0-1].substr(0, $$[$0-1].length - 1);
      $$[$0] = resolveIRI($$[$0]);
      Parser.prefixes[$$[$0-1]] = $$[$0];
    
break;
case 6:
this.$ = extend($$[$0-3], groupDatasets($$[$0-2]), $$[$0-1], $$[$0]);
break;
case 7:

      // Check for projection of ungrouped variable
      if (!Parser.skipValidation) {
        const counts = flatten($$[$0-3].variables.map(vars => getAggregatesOfExpression(vars.expression)))
          .some(agg => agg.aggregation === "count" && !(agg.expression instanceof Wildcard));
        if (counts || $$[$0].group) {
          for (const selectVar of $$[$0-3].variables) {
            if (selectVar.termType === "Variable") {
              if (!$$[$0].group || !$$[$0].group.map(groupVar => getExpressionId(groupVar)).includes(getExpressionId(selectVar))) {
                throw Error("Projection of ungrouped variable (?" + getExpressionId(selectVar) + ")");
              }
            } else if (getAggregatesOfExpression(selectVar.expression).length === 0) {
              const usedVars = getVariablesFromExpression(selectVar.expression);
              for (const usedVar of usedVars) {
                if (!$$[$0].group || !$$[$0].group.map || !$$[$0].group.map(groupVar => getExpressionId(groupVar)).includes(getExpressionId(usedVar))) {
                  throw Error("Use of ungrouped variable in projection of operation (?" + getExpressionId(usedVar) + ")");
                }
              }
            }
          }
        }
      }
      // Check if id of each AS-selected column is not yet bound by subquery
      const subqueries = $$[$0-1].where.filter(w => w.type === "query");
      if (subqueries.length > 0) {
        const selectedVarIds = $$[$0-3].variables.filter(v => v.variable && v.variable.value).map(v => v.variable.value);
        const subqueryIds = flatten(subqueries.map(sub => sub.variables)).map(v => v.value || v.variable.value);
        for (const selectedVarId of selectedVarIds) {
          if (subqueryIds.indexOf(selectedVarId) >= 0) {
            throw Error("Target id of 'AS' (?" + selectedVarId + ") already used in subquery");
          }
        }
      }
      this.$ = extend($$[$0-3], groupDatasets($$[$0-2]), $$[$0-1], $$[$0])
    
break;
case 8:
this.$ = extend($$[$0-1], {variables: [new Wildcard()]});
break;
case 9:

      // Check if id of each selected column is different
      const selectedVarIds = $$[$0].map(v => v.value || v.variable.value);
      const duplicates = getDuplicatesInArray(selectedVarIds);
      if (duplicates.length > 0) {
        throw Error("Two or more of the resulting columns have the same name (?" + duplicates[0] + ")");
      }

      this.$ = extend($$[$0-1], { variables: $$[$0] })
    
break;
case 10:
this.$ = extend({ queryType: 'SELECT'}, $$[$0] && ($$[$0-1] = lowercase($$[$0]), $$[$0] = {}, $$[$0][$$[$0-1]] = true, $$[$0]));
break;
case 11: case 12:
this.$ = extend($$[$0-3], $$[$0-2], $$[$0-1], $$[$0], { type: 'query' });
break;
case 13: case 100: case 137: case 166:
this.$ = toVar($$[$0]);
break;
case 14: case 28:
this.$ = expression($$[$0-3], { variable: toVar($$[$0-1]) });
break;
case 15:
this.$ = ensureSparqlStar(expression($$[$0-3], { variable: toVar($$[$0-1]) }));
break;
case 16:
this.$ = extend({ queryType: 'CONSTRUCT', template: $$[$0-3] }, groupDatasets($$[$0-2]), $$[$0-1], $$[$0]);
break;
case 17:
this.$ = extend({ queryType: 'CONSTRUCT', template: $$[$0-2] = ($$[$0-2] ? $$[$0-2].triples : []) }, groupDatasets($$[$0-5]), { where: [ { type: 'bgp', triples: appendAllTo([], $$[$0-2]) } ] }, $$[$0]);
break;
case 18:
this.$ = extend({ queryType: 'DESCRIBE', variables: $$[$0-3] === '*' ? [new Wildcard()] : $$[$0-3].map(toVar) }, groupDatasets($$[$0-2]), $$[$0-1], $$[$0]);
break;
case 19:
this.$ = extend({ queryType: 'ASK' }, groupDatasets($$[$0-2]), $$[$0-1], $$[$0]);
break;
case 20: case 61:
this.$ = { iri: $$[$0], named: !!$$[$0-1] };
break;
case 21:
this.$ = { where: $$[$0].patterns };
break;
case 22:
this.$ = extend($$[$0-1], $$[$0]);
break;
case 23:
this.$ = extend($$[$0-2], $$[$0-1], $$[$0]);
break;
case 24:
this.$ = { group: $$[$0] };
break;
case 25: case 26: case 32: case 34:
this.$ = expression($$[$0]);
break;
case 27:
this.$ = expression($$[$0-1]);
break;
case 29: case 35:
this.$ = expression(toVar($$[$0]));
break;
case 30:
this.$ = { having: $$[$0] };
break;
case 31:
this.$ = { order: $$[$0] };
break;
case 33:
this.$ = expression($$[$0], { descending: true });
break;
case 36:
this.$ = { limit:  toInt($$[$0]) };
break;
case 37:
this.$ = { offset: toInt($$[$0]) };
break;
case 38:
this.$ = { limit: toInt($$[$0-2]), offset: toInt($$[$0]) };
break;
case 39:
this.$ = { limit: toInt($$[$0]), offset: toInt($$[$0-2]) };
break;
case 40:
this.$ = { type: 'values', values: $$[$0] };
break;
case 41:

      this.$ = $$[$0-1].map(function(v) { var o = {}; o[$$[$0-3]] = v; return o; })
    
break;
case 42:

      this.$ = $$[$0-1].map(function() { return {}; })
    
break;
case 43:

      var length = $$[$0-4].length;
      $$[$0-4] = $$[$0-4].map(toVar);
      this.$ = $$[$0-1].map(function (values) {
        if (values.length !== length)
          throw Error('Inconsistent VALUES length');
        var valuesObject = {};
        for(var i = 0; i<length; i++)
          valuesObject['?' + $$[$0-4][i].value] = values[i];
        return valuesObject;
      });
    
break;
case 46:
this.$ = ensureSparqlStar($$[$0]);
break;
case 47:
this.$ = undefined;
break;
case 48: case 92: case 117: case 167:
this.$ = $$[$0-1];
break;
case 49:
this.$ = { type: 'update', updates: appendTo($$[$0-2], $$[$0-1]) };
break;
case 50:
this.$ = extend({ type: 'load', silent: !!$$[$0-2], source: $$[$0-1] }, $$[$0] && { destination: $$[$0] });
break;
case 51:
this.$ = { type: lowercase($$[$0-2]), silent: !!$$[$0-1], graph: $$[$0] };
break;
case 52:
this.$ = { type: lowercase($$[$0-4]), silent: !!$$[$0-3], source: $$[$0-2], destination: $$[$0] };
break;
case 53:
this.$ = { type: 'create', silent: !!$$[$0-2], graph: { type: 'graph', name: $$[$0] } };
break;
case 54:
this.$ = { updateType: 'insert',      insert: ensureNoVariables($$[$0])                 };
break;
case 55:
this.$ = { updateType: 'delete',      delete: ensureNoBnodes(ensureNoVariables($$[$0])) };
break;
case 56:
this.$ = { updateType: 'deletewhere', delete: ensureNoBnodes($$[$0])                    };
break;
case 57:
this.$ = extend({ updateType: 'insertdelete' }, $$[$0-5], { insert: $$[$0-4] || [] }, { delete: $$[$0-3] || [] }, groupDatasets($$[$0-2], 'using'), { where: $$[$0].patterns });
break;
case 58:
this.$ = extend({ updateType: 'insertdelete' }, $$[$0-5], { delete: $$[$0-4] || [] }, { insert: $$[$0-3] || [] }, groupDatasets($$[$0-2], 'using'), { where: $$[$0].patterns });
break;
case 59:
this.$ = ensureNoBnodes($$[$0]);
break;
case 60: case 63: case 160: case 181:
this.$ = $$[$0];
break;
case 62:
this.$ = { graph: $$[$0] };
break;
case 64:
this.$ = { type: 'graph', default: true };
break;
case 65: case 66:
this.$ = { type: 'graph', name: $$[$0] };
break;
case 67:
 this.$ = {}; this.$[lowercase($$[$0])] = true; 
break;
case 68:
this.$ = $$[$0-2] ? unionAll($$[$0-1], [$$[$0-2]]) : unionAll($$[$0-1]);
break;
case 69:

      var graph = extend($$[$0-3] || { triples: [] }, { type: 'graph', name: toVar($$[$0-5]) });
      this.$ = $$[$0] ? [graph, $$[$0]] : [graph];
    
break;
case 70: case 75:
this.$ = { type: 'bgp', triples: unionAll($$[$0-2], [$$[$0-1]]) };
break;
case 71:
this.$ = { type: 'group', patterns: [ $$[$0-1] ] };
break;
case 72:

      // For every binding
      for (const binding of $$[$0-1].filter(el => el.type === "bind")) {
        const index = $$[$0-1].indexOf(binding);
        const boundVars = new Set();
        //Collect all bounded variables before the binding
        for (const el of $$[$0-1].slice(0, index)) {
          if (el.type === "group" || el.type === "bgp") {
            getBoundVarsFromGroupGraphPattern(el).forEach(boundVar => boundVars.add(boundVar));
          }
        }
        // If binding with a non-free variable, throw error
        if (boundVars.has(binding.variable.value)) {
          throw Error("Variable used to bind is already bound (?" + binding.variable.value + ")");
        }
      }
      this.$ = { type: 'group', patterns: $$[$0-1] }
    
break;
case 73:
this.$ = $$[$0-1] ? unionAll([$$[$0-1]], $$[$0]) : unionAll($$[$0]);
break;
case 74:
this.$ = $$[$0] ? [$$[$0-2], $$[$0]] : $$[$0-2];
break;
case 76:

      if ($$[$0-1].length)
        this.$ = { type: 'union', patterns: unionAll($$[$0-1].map(degroupSingle), [degroupSingle($$[$0])]) };
      else
        this.$ = $$[$0];
    
break;
case 77:
this.$ = extend($$[$0], { type: 'optional' });
break;
case 78:
this.$ = extend($$[$0], { type: 'minus' });
break;
case 79:
this.$ = extend($$[$0], { type: 'graph', name: toVar($$[$0-1]) });
break;
case 80:
this.$ = extend($$[$0], { type: 'service', name: toVar($$[$0-1]), silent: !!$$[$0-2] });
break;
case 81:
this.$ = { type: 'filter', expression: $$[$0] };
break;
case 82:
this.$ = { type: 'bind', variable: toVar($$[$0-1]), expression: $$[$0-3] };
break;
case 83:
this.$ = ensureSparqlStar({ type: 'bind', variable: toVar($$[$0-1]), expression: $$[$0-3] });
break;
case 88:
this.$ = { type: 'functionCall', function: $$[$0-1], args: [] };
break;
case 89:
this.$ = { type: 'functionCall', function: $$[$0-5], args: appendTo($$[$0-2], $$[$0-1]), distinct: !!$$[$0-3] };
break;
case 90: case 108: case 119: case 211: case 219: case 221: case 233: case 235: case 245: case 249: case 269: case 271: case 275: case 279: case 302: case 308: case 319: case 329: case 335: case 341: case 345: case 355: case 357: case 361: case 369: case 373: case 375: case 383: case 385: case 389: case 391: case 400: case 432: case 434: case 444: case 448: case 450: case 452:
this.$ = [];
break;
case 91:
this.$ = appendTo($$[$0-2], $$[$0-1]);
break;
case 93:
this.$ = unionAll($$[$0-2], [$$[$0-1]]);
break;
case 94: case 105:
this.$ = $$[$0].map(function (t) { return extend(triple($$[$0-1]), t); });
break;
case 95:
this.$ = appendAllTo($$[$0].map(function (t) { return extend(triple($$[$0-1].entity), t); }), $$[$0-1].triples) /* the subject is a blank node, possibly with more triples */;
break;
case 97:
this.$ = unionAll([$$[$0-1]], $$[$0]);
break;
case 98:
this.$ = unionAll($$[$0]);
break;
case 99:
this.$ = objectListToTriples($$[$0-1], $$[$0]);
break;
case 102: case 115: case 122:
this.$ = Parser.factory.namedNode(RDF_TYPE);
break;
case 103: case 104:
this.$ = appendTo($$[$0-1], $$[$0]);
break;
case 106:
this.$ = !$$[$0] ? $$[$0-1].triples : appendAllTo($$[$0].map(function (t) { return extend(triple($$[$0-1].entity), t); }), $$[$0-1].triples) /* the subject is a blank node, possibly with more triples */;
break;
case 107:
this.$ = objectListToTriples(toVar($$[$0-3]), appendTo($$[$0-2], $$[$0-1]), $$[$0]);
break;
case 109:
this.$ = objectListToTriples(toVar($$[$0-1]), $$[$0]);
break;
case 110:
this.$ = $$[$0-1].length ? path('|',appendTo($$[$0-1], $$[$0])) : $$[$0];
break;
case 111:
this.$ = $$[$0-1].length ? path('/', appendTo($$[$0-1], $$[$0])) : $$[$0];
break;
case 112:
this.$ = $$[$0] ? path($$[$0], [$$[$0-1]]) : $$[$0-1];
break;
case 113:
this.$ = $$[$0-1] ? path($$[$0-1], [$$[$0]]) : $$[$0];;
break;
case 116: case 123:
this.$ = path($$[$0-1], [$$[$0]]);
break;
case 120:
this.$ = path('|', appendTo($$[$0-2], $$[$0-1]));
break;
case 124:
this.$ = path($$[$0-1], [Parser.factory.namedNode(RDF_TYPE)]);
break;
case 125: case 127:
this.$ = createList($$[$0-1]);
break;
case 126: case 128:
this.$ = createAnonymousObject($$[$0-1]);
break;
case 129:
this.$ = { entity: $$[$0], triples: [] } /* for consistency with TriplesNode */;
break;
case 131:
this.$ = { entity: $$[$0], triples: [] } /* for consistency with TriplesNodePath */;
break;
case 133: case 135:
this.$ = ensureSparqlStar(Parser.factory.quad($$[$0-4], $$[$0-3], $$[$0-2], toVar($$[$0-6])));
break;
case 134: case 136:
this.$ = ensureSparqlStar(Parser.factory.quad($$[$0-3], $$[$0-2], $$[$0-1]));
break;
case 141:
this.$ = blank($$[$0].replace(/^(_:)/,''));;
break;
case 142:
this.$ = blank();
break;
case 143:
this.$ = Parser.factory.namedNode(RDF_NIL);
break;
case 144: case 146: case 151: case 155:
this.$ = createOperationTree($$[$0-1], $$[$0]);
break;
case 145:
this.$ = ['||', $$[$0]];
break;
case 147:
this.$ = ['&&', $$[$0]];
break;
case 149:
this.$ = operation($$[$0-1], [$$[$0-2], $$[$0]]);
break;
case 150:
this.$ = operation($$[$0-2] ? 'notin' : 'in', [$$[$0-3], $$[$0]]);
break;
case 152: case 156:
this.$ = [$$[$0-1], $$[$0]];
break;
case 153:
this.$ = ['+', createOperationTree($$[$0-1], $$[$0])];
break;
case 154:

      var negatedLiteral = createTypedLiteral($$[$0-1].value.replace('-', ''), $$[$0-1].datatype);
      this.$ = ['-', createOperationTree(negatedLiteral, $$[$0])];
    
break;
case 157:
this.$ = operation('UPLUS', [$$[$0]]);
break;
case 158:
this.$ = operation($$[$0-1], [$$[$0]]);
break;
case 159:
this.$ = operation('UMINUS', [$$[$0]]);
break;
case 169:
this.$ = operation(lowercase($$[$0-1]));
break;
case 170:
this.$ = operation(lowercase($$[$0-3]), [$$[$0-1]]);
break;
case 171:
this.$ = operation(lowercase($$[$0-5]), [$$[$0-3], $$[$0-1]]);
break;
case 172:
this.$ = operation(lowercase($$[$0-7]), [$$[$0-5], $$[$0-3], $$[$0-1]]);
break;
case 173:
this.$ = operation(lowercase($$[$0-1]), $$[$0]);
break;
case 174:
this.$ = operation('bound', [toVar($$[$0-1])]);
break;
case 175:
this.$ = operation($$[$0-1], []);
break;
case 176:
this.$ = operation($$[$0-3], [$$[$0-1]]);
break;
case 177:
this.$ = operation($$[$0-2] ? 'notexists' :'exists', [degroupSingle($$[$0])]);
break;
case 178: case 179:
this.$ = expression($$[$0-1], { type: 'aggregate', aggregation: lowercase($$[$0-4]), distinct: !!$$[$0-2] });
break;
case 180:
this.$ = expression($$[$0-2], { type: 'aggregate', aggregation: lowercase($$[$0-5]), distinct: !!$$[$0-3], separator: typeof $$[$0-1] === 'string' ? $$[$0-1] : ' ' });
break;
case 182:
this.$ = createTypedLiteral($$[$0]);
break;
case 183:
this.$ = createLangLiteral($$[$0-1], lowercase($$[$0].substr(1)));
break;
case 184:
this.$ = createTypedLiteral($$[$0-2], $$[$0]);
break;
case 185: case 198:
this.$ = createTypedLiteral($$[$0], XSD_INTEGER);
break;
case 186: case 199:
this.$ = createTypedLiteral($$[$0], XSD_DECIMAL);
break;
case 187: case 200:
this.$ = createTypedLiteral(lowercase($$[$0]), XSD_DOUBLE);
break;
case 190:
this.$ = createTypedLiteral($$[$0].toLowerCase(), XSD_BOOLEAN);
break;
case 191: case 192:
this.$ = unescapeString($$[$0], 1);
break;
case 193: case 194:
this.$ = unescapeString($$[$0], 3);
break;
case 195:
this.$ = createTypedLiteral($$[$0].substr(1), XSD_INTEGER);
break;
case 196:
this.$ = createTypedLiteral($$[$0].substr(1), XSD_DECIMAL);
break;
case 197:
this.$ = createTypedLiteral($$[$0].substr(1).toLowerCase(), XSD_DOUBLE);
break;
case 201:
this.$ = Parser.factory.namedNode(resolveIRI($$[$0]));
break;
case 202:

      var namePos = $$[$0].indexOf(':'),
          prefix = $$[$0].substr(0, namePos),
          expansion = Parser.prefixes[prefix];
      if (!expansion) throw new Error('Unknown prefix: ' + prefix);
      var uriString = resolveIRI(expansion + $$[$0].substr(namePos + 1));
      this.$ = Parser.factory.namedNode(uriString);
    
break;
case 203:

      $$[$0] = $$[$0].substr(0, $$[$0].length - 1);
      if (!($$[$0] in Parser.prefixes)) throw new Error('Unknown prefix: ' + $$[$0]);
      var uriString = resolveIRI(Parser.prefixes[$$[$0]]);
      this.$ = Parser.factory.namedNode(uriString);
    
break;
case 212: case 220: case 222: case 224: case 234: case 236: case 242: case 246: case 250: case 264: case 266: case 268: case 270: case 272: case 274: case 276: case 278: case 303: case 309: case 320: case 336: case 370: case 386: case 405: case 407: case 433: case 435: case 445: case 449: case 451: case 453:
$$[$0-1].push($$[$0]);
break;
case 223: case 241: case 263: case 265: case 267: case 273: case 277: case 404: case 406:
this.$ = [$$[$0]];
break;
case 280:
$$[$0-3].push($$[$0-2]);
break;
case 330: case 342: case 346: case 356: case 358: case 362: case 374: case 376: case 384: case 390: case 392: case 401:
$$[$0-2].push($$[$0-1]);
break;
}
},
table: [o($V0,$V1,{3:1,4:2,7:3}),{1:[3]},o($V2,[2,279],{5:4,8:5,313:6,210:7,9:8,103:9,211:10,17:11,40:12,49:13,54:14,104:15,18:16,22:17,25:21,6:[2,204],13:$V3,16:$V3,35:$V3,195:$V3,219:$V3,224:$V3,312:$V3,28:$V4,41:[1,18],50:[1,19],55:[1,20]}),o([6,13,16,28,35,41,50,55,107,117,120,122,123,132,133,138,195,219,224,312,322,323,324,325,326],[2,2],{314:23,11:24,14:25,12:[1,26],15:[1,27]}),{6:[1,28]},{6:[2,206]},{6:[2,207]},{6:[2,208]},{6:[2,217],10:29,89:30,90:$V5},{6:[2,205]},o($V6,[2,391],{212:32,213:33}),o($V7,[2,213]),o($V7,[2,214]),o($V7,[2,215]),o($V7,[2,216]),{105:34,107:[1,35],110:36,113:37,117:[1,38],120:[1,39],122:[1,40],123:[1,41],124:42,128:43,132:[2,304],133:[2,298],137:49,138:[1,50],322:[1,44],323:[1,45],324:[1,46],325:[1,47],326:[1,48]},o($V8,[2,219],{19:51}),o($V8,[2,221],{23:52}),o($V9,[2,235],{42:53,44:54,46:[1,55]}),{13:$Va,16:$Vb,26:[1,58],34:$Vc,51:56,60:61,312:$Vd,318:59,319:57},o($V8,[2,249],{56:65}),{26:[1,66],27:67,33:68,34:$Ve,35:$Vf},o($Vg,[2,227],{29:71,315:72,316:[1,73],317:[1,74]}),o($V0,[2,212]),o($V0,[2,209]),o($V0,[2,210]),{13:[1,75]},{16:[1,76]},{1:[2,1]},{6:[2,3]},{6:[2,218]},{34:[1,78],35:[1,80],91:77,93:[1,79]},o([6,13,16,34,35,38,87,93,226,231,245,246,299,300,301,302,303,304,305,306,307,308,309,310,311,312],[2,110],{330:[1,81]}),o($Vh,[2,398],{214:82,218:83,224:[1,84]}),{6:[2,281],106:85,191:[1,86]},o($Vi,[2,283],{108:87,321:[1,88]}),o($Vj,[2,289],{111:89,321:[1,90]}),o($Vk,[2,294],{114:91,321:[1,92]}),{118:93,119:[2,296],321:[1,94]},{46:$Vl,121:95},{46:$Vl,121:97},{46:$Vl,121:98},{125:99,133:$Vm},{129:101,132:$Vn},o($Vo,[2,287]),o($Vo,[2,288]),o($Vp,[2,291]),o($Vp,[2,292]),o($Vp,[2,293]),{132:[2,305],133:[2,299]},{13:$Va,16:$Vb,60:103,312:$Vd},{20:104,45:$Vq,46:$Vr,57:105,58:$Vs,61:106},{20:109,45:$Vq,46:$Vr,57:110,58:$Vs,61:106},o($V8,[2,233],{43:111}),{45:[1,112],57:113,58:$Vs},o($Vt,[2,361],{179:114,180:115,181:116,48:[2,359]}),o($Vu,[2,245],{52:117}),o($Vu,[2,243],{60:61,318:118,13:$Va,16:$Vb,34:$Vc,312:$Vd}),o($Vu,[2,244]),o($Vv,[2,241]),o($Vv,[2,239]),o($Vv,[2,240]),o($Vw,[2,201]),o($Vw,[2,202]),o($Vw,[2,203]),{20:119,45:$Vq,46:$Vr,57:120,58:$Vs,61:106},o($V8,[2,8]),o($V8,[2,9],{33:121,34:$Ve,35:$Vf}),o($Vx,[2,223]),o($Vx,[2,13]),{13:$Va,16:$Vb,34:$Vy,35:$Vz,36:122,39:123,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,231:$VC,247:124,251:126,255:127,259:128,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},o($Vg,[2,10]),o($Vg,[2,228]),o($Vg,[2,225]),o($Vg,[2,226]),o($V0,[2,4]),{13:[1,176]},o($V61,[2,40]),{46:[1,177]},{46:[1,178]},{34:[1,180],95:179},o($V6,[2,390]),o([6,13,16,34,35,38,87,93,226,231,245,246,299,300,301,302,303,304,305,306,307,308,309,310,311,312,330],[2,111],{331:[1,181]}),{13:$Va,16:$Vb,35:[1,187],60:184,195:[1,185],215:182,216:183,219:[1,186],312:$Vd},o($Vh,[2,399]),{6:[2,49]},o($V0,$V1,{7:3,4:188}),{13:$Va,16:$Vb,60:189,312:$Vd},o($Vi,[2,284]),{112:190,119:[1,191],141:[1,193],143:192,320:[1,194],327:[1,195]},o($Vj,[2,290]),o($Vi,$V71,{115:196,142:198,119:$V81,141:$V91}),o($Vk,[2,295]),{119:[1,200]},{119:[2,297]},o($Va1,[2,54]),o($Vt,$Vb1,{144:201,151:202,152:203,48:$Vc1,119:$Vc1}),o($Va1,[2,55]),o($Va1,[2,56]),o($Vd1,[2,300],{126:204,129:205,132:$Vn}),{46:$Vl,121:206},o($Vd1,[2,306],{130:207,125:208,133:$Vm}),{46:$Vl,121:209},o([132,133],[2,62]),o($Ve1,$Vf1,{21:210,64:211,74:212,75:$Vg1}),o($V8,[2,220]),{46:$Vh1,62:214},o($Vi,[2,251],{59:216,320:[1,217]}),{46:[2,254]},o($Vi1,$Vj1,{24:218,63:219,67:220,68:$Vk1}),o($V8,[2,222]),{20:222,45:$Vq,46:$Vr,57:223,58:$Vs,61:106},{46:[1,224]},o($V9,[2,236]),{48:[1,225]},{48:[2,360]},{13:$Va,16:$Vb,34:$Vl1,35:$Vm1,39:230,60:235,87:$VA,93:$Vn1,98:236,153:226,183:227,185:228,226:$Vo1,231:$VC,243:229,244:234,245:$Vp1,246:$Vq1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},o($Vr1,[2,247],{61:106,53:240,57:241,20:242,45:$Vq,46:$Vr,58:$Vs}),o($Vv,[2,242]),o($Vi1,$Vj1,{63:219,67:220,24:243,68:$Vk1}),o($V8,[2,250]),o($Vx,[2,224]),{37:[1,244]},{37:[1,245]},o($Vs1,[2,432],{248:246}),{13:$Va,16:$Vb,34:$Vl1,39:249,60:235,87:$VA,93:$Vn1,98:236,119:[1,247],231:$VC,236:248,243:250,244:234,245:$Vp1,246:$Vq1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},o($Vt1,[2,434],{252:251}),o($Vt1,[2,148],{256:252,257:253,258:[2,442],295:[1,254],334:[1,255],335:[1,256],336:[1,257],337:[1,258],338:[1,259],339:[1,260]}),o($Vu1,[2,444],{260:261}),o($Vv1,[2,452],{268:262}),{13:$Va,16:$Vb,34:$Vy,35:$Vz,60:136,72:135,73:137,82:134,87:$VA,98:138,263:154,265:155,272:263,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},{13:$Va,16:$Vb,34:$Vy,35:$Vz,60:136,72:135,73:137,82:134,87:$VA,98:138,263:154,265:155,272:264,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},{13:$Va,16:$Vb,34:$Vy,35:$Vz,60:136,72:135,73:137,82:134,87:$VA,98:138,263:154,265:155,272:265,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},o($Vv1,[2,160]),o($Vv1,[2,161]),o($Vv1,[2,162]),o($Vv1,[2,163],{35:$Vw1,93:$Vx1}),o($Vv1,[2,164]),o($Vv1,[2,165]),o($Vv1,[2,166]),{13:$Va,16:$Vb,34:$Vy,35:$Vz,36:268,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,247:124,251:126,255:127,259:128,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},o($Vy1,[2,168]),{93:[1,269]},{35:[1,270]},{35:[1,271]},{35:[1,272]},{35:$Vz1,93:$VA1,177:273},{35:[1,276]},{35:[1,278],93:[1,277]},{284:[1,279]},o($VB1,[2,182],{297:[1,280],298:[1,281]}),o($VB1,[2,185]),o($VB1,[2,186]),o($VB1,[2,187]),o($VB1,[2,188]),o($VB1,[2,189]),o($VB1,[2,190]),{35:[1,282]},{35:[1,283]},{35:[1,284]},o($VC1,[2,456]),o($VC1,[2,457]),o($VC1,[2,458]),o($VC1,[2,459]),o($VC1,[2,460]),{284:[2,462]},o($VD1,[2,191]),o($VD1,[2,192]),o($VD1,[2,193]),o($VD1,[2,194]),o($VB1,[2,195]),o($VB1,[2,196]),o($VB1,[2,197]),o($VB1,[2,198]),o($VB1,[2,199]),o($VB1,[2,200]),o($V0,[2,5]),o($VE1,[2,269],{92:285}),o($VF1,[2,271],{94:286}),{34:[1,288],38:[1,287]},o($VG1,[2,273]),o($V6,[2,392]),o($VH1,[2,113]),o($VH1,[2,396],{217:289,332:290,26:[1,292],271:[1,293],333:[1,291]}),o($VI1,[2,114]),o($VI1,[2,115]),{13:$Va,16:$Vb,35:[1,297],60:298,93:[1,296],195:$VJ1,220:294,221:295,224:$VK1,312:$Vd},o($V6,$V3,{211:10,210:301}),o($V2,[2,280],{6:[2,282]}),o($Va1,[2,285],{109:302,139:303,140:[1,304]}),o($Va1,[2,51]),{13:$Va,16:$Vb,60:305,312:$Vd},o($Va1,[2,67]),o($Va1,[2,314]),o($Va1,[2,315]),o($Va1,[2,316]),{116:[1,306]},o($VL1,[2,64]),{13:$Va,16:$Vb,60:307,312:$Vd},o($Vi,[2,313]),{13:$Va,16:$Vb,60:308,312:$Vd},o($VM1,[2,319],{145:309}),o($VM1,[2,318]),{13:$Va,16:$Vb,34:$Vl1,35:$Vm1,39:230,60:235,87:$VA,93:$Vn1,98:236,153:310,183:227,185:228,226:$Vo1,231:$VC,243:229,244:234,245:$Vp1,246:$Vq1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},o($Vd1,[2,302],{127:311}),o($Vd1,[2,301]),o([45,132,135],[2,60]),o($Vd1,[2,308],{131:312}),o($Vd1,[2,307]),o([45,133,135],[2,59]),o($V7,[2,6]),o($VN1,[2,259],{65:313,77:314,78:[1,315]}),o($Ve1,[2,258]),{13:$Va,16:$Vb,35:$Vz,60:321,72:319,73:320,76:316,82:318,84:317,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},o([6,48,68,75,78,86,88,90],[2,21]),o($Vt,$VO1,{25:21,30:322,155:323,18:324,22:325,156:326,162:327,163:328,28:$V4,46:$VP1,48:$VP1,90:$VP1,119:$VP1,167:$VP1,168:$VP1,170:$VP1,173:$VP1,174:$VP1}),{13:$Va,16:$Vb,60:329,312:$Vd},o($Vi,[2,252]),o($V7,[2,7]),o($Ve1,$Vf1,{64:211,74:212,21:330,75:$Vg1}),o($Vi1,[2,256]),{69:[1,331]},o($Vi1,$Vj1,{63:219,67:220,24:332,68:$Vk1}),o($V8,[2,234]),o($Vt,$Vb1,{152:203,47:333,151:334,48:[2,237]}),o($V8,[2,92]),{48:[2,363],182:335,328:[1,336]},{13:$Va,16:$Vb,34:$VQ1,60:341,184:337,188:338,193:339,195:$VR1,312:$Vd},o($VS1,[2,367],{188:338,193:339,60:341,186:343,187:344,184:345,13:$Va,16:$Vb,34:$VQ1,195:$VR1,312:$Vd}),o($VT1,[2,365]),o($VT1,[2,366]),{13:$Va,16:$Vb,34:$Vl1,35:$Vm1,39:351,60:235,87:$VA,93:$Vn1,98:236,185:349,197:347,225:346,226:$Vo1,229:348,231:$VC,243:350,244:234,245:$Vp1,246:$Vq1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},{13:$Va,16:$Vb,34:$VQ1,60:341,184:352,188:338,193:339,195:$VR1,312:$Vd},o($VU1,[2,137]),o($VU1,[2,138]),o($VU1,[2,139]),o($VU1,[2,140]),o($VU1,[2,141]),o($VU1,[2,142]),o($VU1,[2,143]),o($Vi1,$Vj1,{63:219,67:220,24:353,68:$Vk1}),o($Vu,[2,246]),o($Vr1,[2,248]),o($V7,[2,19]),{34:[1,354]},{34:[1,355]},o([37,38,191,278],[2,144],{249:356,250:[1,357]}),{13:$Va,16:$Vb,34:[1,359],60:360,232:358,312:$Vd},{13:$Va,16:$Vb,34:$VQ1,60:341,193:361,195:$VR1,312:$Vd},o($VT1,[2,418]),o($VT1,[2,419]),o($Vs1,[2,146],{253:362,254:[1,363]}),{13:$Va,16:$Vb,34:$Vy,35:$Vz,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,255:364,259:128,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},{258:[1,365]},o($VV1,[2,436]),o($VV1,[2,437]),o($VV1,[2,438]),o($VV1,[2,439]),o($VV1,[2,440]),o($VV1,[2,441]),{258:[2,443]},o([37,38,191,250,254,258,278,295,334,335,336,337,338,339],[2,151],{261:366,262:367,263:368,265:369,271:[1,370],273:[1,371],306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$}),o($Vu1,[2,155],{269:372,270:373,26:$VW1,331:$VX1}),o($Vv1,[2,157]),o($Vv1,[2,158]),o($Vv1,[2,159]),o($Vy1,[2,88]),o($VV1,[2,353],{175:376,316:[1,377]}),{38:[1,378]},o($Vy1,[2,169]),{13:$Va,16:$Vb,34:$Vy,35:$Vz,36:379,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,247:124,251:126,255:127,259:128,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},{13:$Va,16:$Vb,34:$Vy,35:$Vz,36:380,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,247:124,251:126,255:127,259:128,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},{13:$Va,16:$Vb,34:$Vy,35:$Vz,36:381,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,247:124,251:126,255:127,259:128,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},o($Vy1,[2,173]),o($Vy1,[2,90]),o($VV1,[2,357],{178:382}),{34:[1,383]},o($Vy1,[2,175]),{13:$Va,16:$Vb,34:$Vy,35:$Vz,36:384,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,247:124,251:126,255:127,259:128,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},{46:$Vh1,62:385},o($VB1,[2,183]),{13:$Va,16:$Vb,60:386,312:$Vd},o($VY1,[2,463],{286:387,316:[1,388]}),o($VV1,[2,467],{289:389,316:[1,390]}),o($VV1,[2,469],{291:391,316:[1,392]}),{13:$Va,16:$Vb,48:[1,393],60:395,87:$VA,97:394,98:396,99:397,100:$VZ1,231:$V_1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},{48:[1,400],93:[1,401]},{46:[1,402]},o($VG1,[2,274]),o($VH1,[2,112]),o($VH1,[2,397]),o($VH1,[2,393]),o($VH1,[2,394]),o($VH1,[2,395]),o($VI1,[2,116]),o($VI1,[2,118]),o($VI1,[2,119]),o($V$1,[2,400],{222:403}),o($VI1,[2,121]),o($VI1,[2,122]),{13:$Va,16:$Vb,60:404,195:[1,405],312:$Vd},{38:[1,406]},o($Va1,[2,50]),o($Va1,[2,286]),{119:[1,407]},o($Va1,[2,66]),o($Vi,$V71,{142:198,115:408,119:$V81,141:$V91}),o($VL1,[2,65]),o($Va1,[2,53]),{48:[1,409],119:[1,411],146:410},o($VM1,[2,331],{154:412,328:[1,413]}),{45:[1,414],134:415,135:$V02},{45:[1,417],134:418,135:$V02},o($V12,[2,261],{66:419,85:420,86:[1,421],88:[1,422]}),o($VN1,[2,260]),{69:[1,423]},o($Ve1,[2,30],{274:141,280:146,283:149,82:318,72:319,73:320,60:321,84:424,13:$Va,16:$Vb,35:$Vz,275:$VF,276:$VG,277:$VH,279:$VI,281:$VJ,282:$VK,284:$VL,285:$VM,288:$VN,290:$VO,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51}),o($V22,[2,265]),o($V32,[2,85]),o($V32,[2,86]),o($V32,[2,87]),{35:$Vw1,93:$Vx1},{48:[1,425]},{48:[1,426]},{20:427,45:$Vq,46:$Vr,61:106},{20:428,45:$Vq,46:$Vr,61:106},o($V42,[2,335],{157:429}),o($V42,[2,334]),{13:$Va,16:$Vb,34:$Vl1,35:$V52,39:434,60:235,87:$VA,93:$Vn1,98:236,164:430,201:431,203:432,226:$V62,231:$VC,243:433,244:234,245:$Vp1,246:$Vq1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},o($Vu,[2,20]),o($V12,[2,22]),{13:$Va,16:$Vb,34:$V72,35:$V82,60:321,70:437,71:438,72:439,73:440,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},o($V7,[2,16]),{48:[1,443]},{48:[2,238]},{48:[2,93]},o($Vt,[2,362],{48:[2,364]}),o($VS1,[2,94]),o($V92,[2,369],{189:444}),o($Vt,[2,373],{194:445,196:446}),o($Vt,[2,100]),o($Vt,[2,101]),o($Vt,[2,102]),o($VS1,[2,95]),o($VS1,[2,96]),o($VS1,[2,368]),{13:$Va,16:$Vb,34:$Vl1,35:$Vm1,38:[1,447],39:351,60:235,87:$VA,93:$Vn1,98:236,185:349,197:448,226:$Vo1,229:348,231:$VC,243:350,244:234,245:$Vp1,246:$Vq1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},o($Va2,[2,404]),o($Vb2,[2,129]),o($Vb2,[2,130]),o($Vb2,[2,408]),o($Vb2,[2,409]),{227:[1,449]},o($V7,[2,18]),{38:[1,450]},{38:[1,451]},o($Vs1,[2,433]),{13:$Va,16:$Vb,34:$Vy,35:$Vz,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,247:452,251:126,255:127,259:128,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},{46:[1,453]},{46:[2,412]},{46:[2,413]},{13:$Va,16:$Vb,34:$Vl1,39:455,60:235,87:$VA,93:$Vn1,98:236,231:$VC,237:454,243:456,244:234,245:$Vp1,246:$Vq1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},o($Vt1,[2,435]),{13:$Va,16:$Vb,34:$Vy,35:$Vz,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,251:457,255:127,259:128,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},o($Vt1,[2,149]),{35:$Vz1,93:$VA1,177:458},o($Vu1,[2,445]),{13:$Va,16:$Vb,34:$Vy,35:$Vz,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,259:459,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},o($Vv1,[2,448],{264:460}),o($Vv1,[2,450],{266:461}),o($VV1,[2,446]),o($VV1,[2,447]),o($Vv1,[2,453]),{13:$Va,16:$Vb,34:$Vy,35:$Vz,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,263:154,265:155,267:462,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},o($VV1,[2,454]),o($VV1,[2,455]),o($VV1,[2,355],{176:463}),o($VV1,[2,354]),o([6,13,16,26,34,35,37,38,46,48,78,81,83,86,87,88,90,93,119,167,168,170,173,174,191,226,231,245,246,250,254,258,271,273,275,276,277,278,279,281,282,284,285,288,290,295,299,300,301,302,303,304,305,306,307,308,309,310,311,312,328,331,334,335,336,337,338,339,340,341,342,343,344],[2,167]),{38:[1,464]},{278:[1,465]},{278:[1,466]},{13:$Va,16:$Vb,34:$Vy,35:$Vz,36:467,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,247:124,251:126,255:127,259:128,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},{38:[1,468]},{38:[1,469]},o($Vy1,[2,177]),o($VB1,[2,184]),{13:$Va,16:$Vb,26:[1,471],34:$Vy,35:$Vz,36:472,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,247:124,251:126,255:127,259:128,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,287:470,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},o($VY1,[2,464]),{13:$Va,16:$Vb,34:$Vy,35:$Vz,36:473,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,247:124,251:126,255:127,259:128,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},o($VV1,[2,468]),{13:$Va,16:$Vb,34:$Vy,35:$Vz,36:474,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,247:124,251:126,255:127,259:128,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},o($VV1,[2,470]),o($V61,[2,41]),o($VE1,[2,270]),o($Vc2,[2,44]),o($Vc2,[2,45]),o($Vc2,[2,46]),o($Vc2,[2,47]),{13:$Va,16:$Vb,60:235,87:$VA,93:$Vn1,98:236,99:477,119:[1,475],231:$V_1,241:476,244:478,245:$Vp1,246:$Vq1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},o($V61,[2,42]),o($VF1,[2,272]),o($Vd2,[2,275],{96:479}),{13:$Va,16:$Vb,38:[2,402],60:298,195:$VJ1,221:481,223:480,224:$VK1,312:$Vd},o($VI1,[2,123]),o($VI1,[2,124]),o($VI1,[2,117]),{13:$Va,16:$Vb,60:482,312:$Vd},o($Va1,[2,52]),o([6,45,132,133,135,191],[2,68]),o($VM1,[2,320]),{13:$Va,16:$Vb,34:[1,484],60:485,147:483,312:$Vd},o($VM1,[2,70]),o($Vt,[2,330],{48:$Ve2,119:$Ve2}),{46:$Vh1,62:486},o($Vd1,[2,303]),o($Vi,[2,310],{136:487,320:[1,488]}),{46:$Vh1,62:489},o($Vd1,[2,309]),o($V12,[2,23]),o($V12,[2,262]),{87:[1,490]},{87:[1,491]},{13:$Va,16:$Vb,34:$Vf2,35:$Vz,60:321,72:319,73:320,79:492,80:493,81:$Vg2,82:318,83:$Vh2,84:496,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},o($V22,[2,266]),o($Vi2,[2,71]),o($Vi2,[2,72]),o($Ve1,$Vf1,{64:211,74:212,21:498,75:$Vg1}),o($Vi1,$Vj1,{63:219,67:220,24:499,68:$Vk1}),{46:[2,345],48:[2,73],89:509,90:$V5,119:[1,505],158:500,159:501,166:502,167:[1,503],168:[1,504],170:[1,506],173:[1,507],174:[1,508]},o($V42,[2,343],{165:510,328:[1,511]}),o($V6,$V3,{211:10,202:512,205:513,210:514,34:$Vj2}),o($Vk2,[2,379],{211:10,205:513,210:514,204:516,202:517,13:$V3,16:$V3,35:$V3,195:$V3,219:$V3,224:$V3,312:$V3,34:$Vj2}),o($Vl2,[2,377]),o($Vl2,[2,378]),{13:$Va,16:$Vb,34:$Vl1,35:$V52,39:523,60:235,87:$VA,93:$Vn1,98:236,200:519,203:521,226:$V62,228:518,230:520,231:$VC,243:522,244:234,245:$Vp1,246:$Vq1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},o($V6,$V3,{211:10,205:513,210:514,202:524,34:$Vj2}),o($Vi1,[2,24],{274:141,280:146,283:149,60:321,72:439,73:440,71:525,13:$Va,16:$Vb,34:$V72,35:$V82,275:$VF,276:$VG,277:$VH,279:$VI,281:$VJ,282:$VK,284:$VL,285:$VM,288:$VN,290:$VO,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51}),o($Vm2,[2,263]),o($Vm2,[2,25]),o($Vm2,[2,26]),{13:$Va,16:$Vb,34:$Vy,35:$Vz,36:526,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,247:124,251:126,255:127,259:128,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},o($Vm2,[2,29]),o($Vi1,$Vj1,{63:219,67:220,24:527,68:$Vk1}),o([48,119,227,328],[2,97],{190:528,191:[1,529]}),o($V92,[2,99]),{13:$Va,16:$Vb,34:$Vl1,35:$Vm1,39:351,60:235,87:$VA,93:$Vn1,98:236,185:349,197:530,226:$Vo1,229:348,231:$VC,243:350,244:234,245:$Vp1,246:$Vq1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},o($Vn2,[2,125]),o($Va2,[2,405]),o($Vn2,[2,126]),o($Vx,[2,14]),o($Vx,[2,15]),o($Vs1,[2,145]),{13:$Va,16:$Vb,34:$Vl1,39:532,60:235,87:$VA,93:$Vn1,98:236,231:$VC,233:531,243:533,244:234,245:$Vp1,246:$Vq1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},{235:[1,534]},{235:[2,420]},{235:[2,421]},o($Vt1,[2,147]),o($Vt1,[2,150]),o($Vu1,[2,152]),o($Vu1,[2,153],{270:373,269:535,26:$VW1,331:$VX1}),o($Vu1,[2,154],{270:373,269:536,26:$VW1,331:$VX1}),o($Vv1,[2,156]),{13:$Va,16:$Vb,34:$Vy,35:$Vz,36:537,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,247:124,251:126,255:127,259:128,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},o($Vy1,[2,170]),{13:$Va,16:$Vb,34:$Vy,35:$Vz,36:538,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,247:124,251:126,255:127,259:128,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},{13:$Va,16:$Vb,34:$Vy,35:$Vz,36:539,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,247:124,251:126,255:127,259:128,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},{38:[1,540],278:[1,541]},o($Vy1,[2,174]),o($Vy1,[2,176]),{38:[1,542]},{38:[2,465]},{38:[2,466]},{38:[1,543]},{38:[2,471],191:[1,546],292:544,293:545},{13:$Va,16:$Vb,34:[1,548],60:549,238:547,312:$Vd},{13:$Va,16:$Vb,34:$VQ1,60:341,193:550,195:$VR1,312:$Vd},o($VT1,[2,428]),o($VT1,[2,429]),{35:[1,553],48:[1,551],101:552},{38:[1,554]},{38:[2,403],330:[1,555]},o($Va1,[2,63]),{46:[1,556]},{46:[2,321]},{46:[2,322]},o($Va1,[2,57]),{13:$Va,16:$Vb,60:557,312:$Vd},o($Vi,[2,311]),o($Va1,[2,58]),o($V12,[2,36],{88:[1,558]}),o($V12,[2,37],{86:[1,559]}),o($VN1,[2,31],{274:141,280:146,283:149,82:318,72:319,73:320,60:321,84:496,80:560,13:$Va,16:$Vb,34:$Vf2,35:$Vz,81:$Vg2,83:$Vh2,275:$VF,276:$VG,277:$VH,279:$VI,281:$VJ,282:$VK,284:$VL,285:$VM,288:$VN,290:$VO,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51}),o($Vo2,[2,267]),{35:$Vz,82:561},{35:$Vz,82:562},o($Vo2,[2,34]),o($Vo2,[2,35]),{31:563,48:[2,229],89:564,90:$V5},{32:565,48:[2,231],89:566,90:$V5},o($V42,[2,336]),o($Vp2,[2,337],{160:567,328:[1,568]}),{46:$Vh1,62:569},{46:$Vh1,62:570},{46:$Vh1,62:571},{13:$Va,16:$Vb,34:[1,573],60:574,169:572,312:$Vd},o($Vq2,[2,349],{171:575,321:[1,576]}),{13:$Va,16:$Vb,35:$Vz,60:321,72:319,73:320,82:318,84:577,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},{35:[1,578]},o($Vr2,[2,84]),o($V42,[2,75]),o($Vt,[2,342],{46:$Vs2,48:$Vs2,90:$Vs2,119:$Vs2,167:$Vs2,168:$Vs2,170:$Vs2,173:$Vs2,174:$Vs2}),o($Vk2,[2,105]),o($Vt,[2,383],{206:579}),o($Vt,[2,381]),o($Vt,[2,382]),o($Vk2,[2,106]),o($Vk2,[2,380]),{13:$Va,16:$Vb,34:$Vl1,35:$V52,38:[1,580],39:523,60:235,87:$VA,93:$Vn1,98:236,200:581,203:521,226:$V62,230:520,231:$VC,243:522,244:234,245:$Vp1,246:$Vq1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},o($Va2,[2,406]),o($Vt2,[2,131]),o($Vt2,[2,132]),o($Vt2,[2,410]),o($Vt2,[2,411]),{227:[1,582]},o($Vm2,[2,264]),{37:[1,584],38:[1,583]},o($V7,[2,17]),o($V92,[2,370]),o($V92,[2,371],{193:339,60:341,192:585,188:586,13:$Va,16:$Vb,34:$VQ1,195:$VR1,312:$Vd}),o($V92,[2,103],{278:[1,587]}),{13:$Va,16:$Vb,34:$VQ1,60:341,193:588,195:$VR1,312:$Vd},o($VT1,[2,414]),o($VT1,[2,415]),o($Vu2,[2,134]),o($Vv1,[2,449]),o($Vv1,[2,451]),{38:[1,589],278:[1,590]},{38:[1,591]},{278:[1,592]},o($Vy1,[2,91]),o($VV1,[2,358]),o($Vy1,[2,178]),o($Vy1,[2,179]),{38:[1,593]},{38:[2,472]},{294:[1,594]},{46:[1,595]},{46:[2,422]},{46:[2,423]},{13:$Va,16:$Vb,60:235,87:$VA,93:$Vn1,98:236,99:597,231:$V_1,242:596,244:598,245:$Vp1,246:$Vq1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},o($V61,[2,43]),o($Vd2,[2,276]),{13:$Va,16:$Vb,60:395,87:$VA,97:600,98:396,99:397,100:$VZ1,102:599,231:$V_1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},o($VI1,[2,120]),o($V$1,[2,401]),o($Vt,$Vb1,{152:203,148:601,151:602,48:[2,323]}),o($Vd1,[2,61]),{87:[1,603]},{87:[1,604]},o($Vo2,[2,268]),o($Vo2,[2,32]),o($Vo2,[2,33]),{48:[2,11]},{48:[2,230]},{48:[2,12]},{48:[2,232]},o($Vt,$VO1,{163:328,161:605,162:606,46:$Vv2,48:$Vv2,90:$Vv2,119:$Vv2,167:$Vv2,168:$Vv2,170:$Vv2,173:$Vv2,174:$Vv2}),o($Vp2,[2,338]),o($Vr2,[2,76],{329:[1,607]}),o($Vr2,[2,77]),o($Vr2,[2,78]),{46:$Vh1,62:608},{46:[2,347]},{46:[2,348]},{13:$Va,16:$Vb,34:[1,610],60:611,172:609,312:$Vd},o($Vq2,[2,350]),o($Vr2,[2,81]),{13:$Va,16:$Vb,34:$Vy,35:$Vz,36:612,39:613,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,231:$VC,247:124,251:126,255:127,259:128,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},{13:$Va,16:$Vb,34:$Vl1,35:$V52,39:523,60:235,87:$VA,93:$Vn1,98:236,200:614,203:521,226:$V62,230:520,231:$VC,243:522,244:234,245:$Vp1,246:$Vq1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},o($Vw2,[2,127]),o($Va2,[2,407]),o($Vw2,[2,128]),o($Vm2,[2,27]),{34:[1,615]},o($V92,[2,98]),o($V92,[2,372]),o($Vt,[2,374]),{13:$Va,16:$Vb,34:$Vl1,39:617,60:235,87:$VA,93:$Vn1,98:236,231:$VC,234:616,243:618,244:234,245:$Vp1,246:$Vq1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},o($Vy1,[2,89]),o($VV1,[2,356]),o($Vy1,[2,171]),{13:$Va,16:$Vb,34:$Vy,35:$Vz,36:619,60:136,72:135,73:137,82:134,87:$VA,98:138,219:$VB,247:124,251:126,255:127,259:128,263:154,265:155,267:129,271:$VD,272:133,273:$VE,274:141,275:$VF,276:$VG,277:$VH,279:$VI,280:146,281:$VJ,282:$VK,283:149,284:$VL,285:$VM,288:$VN,290:$VO,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd,339:$V01,340:$V11,341:$V21,342:$V31,343:$V41,344:$V51},o($Vy1,[2,180]),{295:[1,620]},{13:$Va,16:$Vb,60:235,87:$VA,93:$Vn1,98:236,99:622,231:$V_1,239:621,244:623,245:$Vp1,246:$Vq1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},{235:[1,624]},{235:[2,430]},{235:[2,431]},{13:$Va,16:$Vb,38:[1,625],60:395,87:$VA,97:626,98:396,99:397,100:$VZ1,231:$V_1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},o($Vx2,[2,277]),{48:[1,627]},{48:[2,324]},o($V12,[2,38]),o($V12,[2,39]),o($V42,[2,74]),o($V42,[2,340]),{46:[2,346]},o($Vr2,[2,79]),{46:$Vh1,62:628},{46:[2,351]},{46:[2,352]},{37:[1,629]},{37:[1,630]},o($Vy2,[2,385],{207:631,278:[1,632]}),{38:[1,633]},{48:[1,634]},{48:[2,416]},{48:[2,417]},{38:[1,635]},{296:636,302:$VS,303:$VT,304:$VU,305:$VV},{13:$Va,16:$Vb,34:$VQ1,60:341,193:637,195:$VR1,312:$Vd},o($VT1,[2,424]),o($VT1,[2,425]),o($Vz2,[2,136]),o($Vd2,[2,48]),o($Vx2,[2,278]),o($VA2,[2,325],{149:638,328:[1,639]}),o($Vr2,[2,80]),{34:[1,640]},{34:[1,641]},o([46,48,90,119,167,168,170,173,174,227,328],[2,107],{208:642,191:[1,643]}),o($Vt,[2,384]),o($Vm2,[2,28]),{235:[1,644]},o($Vy1,[2,172]),{38:[2,181]},{13:$Va,16:$Vb,60:235,87:$VA,93:$Vn1,98:236,99:646,231:$V_1,240:645,244:647,245:$Vp1,246:$Vq1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},o($Vt,$Vb1,{152:203,150:648,151:649,48:$VB2,119:$VB2}),o($VA2,[2,326]),{38:[1,650]},{38:[1,651]},o($Vy2,[2,386]),o($Vy2,[2,108],{211:10,209:652,210:653,13:$V3,16:$V3,35:$V3,195:$V3,219:$V3,224:$V3,312:$V3,34:[1,654]}),o($Vu2,[2,133]),{48:[1,655]},{48:[2,426]},{48:[2,427]},o($VM1,[2,69]),o($VM1,[2,328]),o($Vr2,[2,82]),o($Vr2,[2,83]),o($Vt,[2,375],{198:656,199:657}),o($Vt,[2,387]),o($Vt,[2,388]),{235:[1,658]},o($Vy2,[2,109]),{13:$Va,16:$Vb,34:$Vl1,35:$V52,39:523,60:235,87:$VA,93:$Vn1,98:236,200:659,203:521,226:$V62,230:520,231:$VC,243:522,244:234,245:$Vp1,246:$Vq1,263:154,265:155,296:150,299:$VP,300:$VQ,301:$VR,302:$VS,303:$VT,304:$VU,305:$VV,306:$VW,307:$VX,308:$VY,309:$VZ,310:$V_,311:$V$,312:$Vd},o($Vz2,[2,135]),o($Vy2,[2,104],{278:[1,660]}),o($Vt,[2,376])],
defaultActions: {5:[2,206],6:[2,207],7:[2,208],9:[2,205],28:[2,1],29:[2,3],30:[2,218],85:[2,49],94:[2,297],108:[2,254],115:[2,360],165:[2,462],260:[2,443],334:[2,238],335:[2,93],359:[2,412],360:[2,413],455:[2,420],456:[2,421],471:[2,465],472:[2,466],484:[2,321],485:[2,322],545:[2,472],548:[2,422],549:[2,423],563:[2,11],564:[2,230],565:[2,12],566:[2,232],573:[2,347],574:[2,348],597:[2,430],598:[2,431],602:[2,324],607:[2,346],610:[2,351],611:[2,352],617:[2,416],618:[2,417],636:[2,181],646:[2,426],647:[2,427]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        var lex = function () {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

  /*
    SPARQL parser in the Jison parser generator format.
  */

  var Wildcard = (__webpack_require__(29511)/* .Wildcard */ .R);

  // Common namespaces and entities
  var RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
      RDF_TYPE  = RDF + 'type',
      RDF_FIRST = RDF + 'first',
      RDF_REST  = RDF + 'rest',
      RDF_NIL   = RDF + 'nil',
      XSD = 'http://www.w3.org/2001/XMLSchema#',
      XSD_INTEGER  = XSD + 'integer',
      XSD_DECIMAL  = XSD + 'decimal',
      XSD_DOUBLE   = XSD + 'double',
      XSD_BOOLEAN  = XSD + 'boolean';

  var base = '', basePath = '', baseRoot = '';

  // Returns a lowercase version of the given string
  function lowercase(string) {
    return string.toLowerCase();
  }

  // Appends the item to the array and returns the array
  function appendTo(array, item) {
    return array.push(item), array;
  }

  // Appends the items to the array and returns the array
  function appendAllTo(array, items) {
    return array.push.apply(array, items), array;
  }

  // Extends a base object with properties of other objects
  function extend(base) {
    if (!base) base = {};
    for (var i = 1, l = arguments.length, arg; i < l && (arg = arguments[i] || {}); i++)
      for (var name in arg)
        base[name] = arg[name];
    return base;
  }

  // Creates an array that contains all items of the given arrays
  function unionAll() {
    var union = [];
    for (var i = 0, l = arguments.length; i < l; i++)
      union = union.concat.apply(union, arguments[i]);
    return union;
  }

  // Resolves an IRI against a base path
  function resolveIRI(iri) {
    // Strip off possible angular brackets
    if (iri[0] === '<')
      iri = iri.substring(1, iri.length - 1);
    // Return absolute IRIs unmodified
    if (/^[a-z]+:/i.test(iri))
      return iri;
    if (!Parser.base)
      throw new Error('Cannot resolve relative IRI ' + iri + ' because no base IRI was set.');
    if (base !== Parser.base) {
      base = Parser.base;
      basePath = base.replace(/[^\/:]*$/, '');
      baseRoot = base.match(/^(?:[a-z]+:\/*)?[^\/]*/)[0];
    }
    switch (iri[0]) {
    // An empty relative IRI indicates the base IRI
    case undefined:
      return base;
    // Resolve relative fragment IRIs against the base IRI
    case '#':
      return base + iri;
    // Resolve relative query string IRIs by replacing the query string
    case '?':
      return base.replace(/(?:\?.*)?$/, iri);
    // Resolve root relative IRIs at the root of the base IRI
    case '/':
      return baseRoot + iri;
    // Resolve all other IRIs at the base IRI's path
    default:
      return basePath + iri;
    }
  }

  // If the item is a variable, ensures it starts with a question mark
  function toVar(variable) {
    if (variable) {
      var first = variable[0];
      if (first === '?' || first === '$') return Parser.factory.variable(variable.substr(1));
    }
    return variable;
  }

  // Creates an operation with the given name and arguments
  function operation(operatorName, args) {
    return { type: 'operation', operator: operatorName, args: args || [] };
  }

  // Creates an expression with the given type and attributes
  function expression(expr, attr) {
    var expression = { expression: expr === '*'? new Wildcard() : expr };
    if (attr)
      for (var a in attr)
        expression[a] = attr[a];
    return expression;
  }

  // Creates a path with the given type and items
  function path(type, items) {
    return { type: 'path', pathType: type, items: items };
  }

  // Transforms a list of operations types and arguments into a tree of operations
  function createOperationTree(initialExpression, operationList) {
    for (var i = 0, l = operationList.length, item; i < l && (item = operationList[i]); i++)
      initialExpression = operation(item[0], [initialExpression, item[1]]);
    return initialExpression;
  }

  // Group datasets by default and named
  function groupDatasets(fromClauses, groupName) {
    var defaults = [], named = [], l = fromClauses.length, fromClause, group = {};
    if (!l)
      return null;
    for (var i = 0; i < l && (fromClause = fromClauses[i]); i++)
      (fromClause.named ? named : defaults).push(fromClause.iri);
    group[groupName || 'from'] = { default: defaults, named: named };
    return group;
  }

  // Converts the string to a number
  function toInt(string) {
    return parseInt(string, 10);
  }

  // Transforms a possibly single group into its patterns
  function degroupSingle(group) {
    return group.type === 'group' && group.patterns.length === 1 ? group.patterns[0] : group;
  }

  // Creates a literal with the given value and type
  function createTypedLiteral(value, type) {
    if (type && type.termType !== 'NamedNode'){
      type = Parser.factory.namedNode(type);
    }
    return Parser.factory.literal(value, type);
  }

  // Creates a literal with the given value and language
  function createLangLiteral(value, lang) {
    return Parser.factory.literal(value, lang);
  }

  // Creates a triple with the given subject, predicate, and object
  function triple(subject, predicate, object) {
    var triple = {};
    if (subject   != null) triple.subject   = subject;
    if (predicate != null) triple.predicate = predicate;
    if (object    != null) triple.object    = object;
    return triple;
  }

  // Creates a new blank node
  function blank(name) {
    if (typeof name === 'string') {  // Only use name if a name is given
      if (name.startsWith('e_')) return Parser.factory.blankNode(name);
      return Parser.factory.blankNode('e_' + name);
    }
    return Parser.factory.blankNode('g_' + blankId++);
  };
  var blankId = 0;
  Parser._resetBlanks = function () { blankId = 0; }

  // Regular expression and replacement strings to escape strings
  var escapeSequence = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\(.)/g,
      escapeReplacements = { '\\': '\\', "'": "'", '"': '"',
                             't': '\t', 'b': '\b', 'n': '\n', 'r': '\r', 'f': '\f' },
      partialSurrogatesWithoutEndpoint = /[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/,
      fromCharCode = String.fromCharCode;

  // Translates escape codes in the string into their textual equivalent
  function unescapeString(string, trimLength) {
    string = string.substring(trimLength, string.length - trimLength);
    try {
      string = string.replace(escapeSequence, function (sequence, unicode4, unicode8, escapedChar) {
        var charCode;
        if (unicode4) {
          charCode = parseInt(unicode4, 16);
          if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance
          return fromCharCode(charCode);
        }
        else if (unicode8) {
          charCode = parseInt(unicode8, 16);
          if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance
          if (charCode < 0xFFFF) return fromCharCode(charCode);
          return fromCharCode(0xD800 + ((charCode -= 0x10000) >> 10), 0xDC00 + (charCode & 0x3FF));
        }
        else {
          var replacement = escapeReplacements[escapedChar];
          if (!replacement) throw new Error();
          return replacement;
        }
      });
    }
    catch (error) { return ''; }

    // Test for invalid unicode surrogate pairs
    if (partialSurrogatesWithoutEndpoint.exec(string)) {
      throw new Error('Invalid unicode codepoint of surrogate pair without corresponding codepoint in ' + string);
    }

    return string;
  }

  // Creates a list, collecting its (possibly blank) items and triples associated with those items
  function createList(objects) {
    var list = blank(), head = list, listItems = [], listTriples, triples = [];
    objects.forEach(function (o) { listItems.push(o.entity); appendAllTo(triples, o.triples); });

    // Build an RDF list out of the items
    for (var i = 0, j = 0, l = listItems.length, listTriples = Array(l * 2); i < l;)
      listTriples[j++] = triple(head, Parser.factory.namedNode(RDF_FIRST), listItems[i]),
      listTriples[j++] = triple(head, Parser.factory.namedNode(RDF_REST),  head = ++i < l ? blank() : Parser.factory.namedNode(RDF_NIL));

    // Return the list's identifier, its triples, and the triples associated with its items
    return { entity: list, triples: appendAllTo(listTriples, triples) };
  }

  // Creates a blank node identifier, collecting triples with that blank node as subject
  function createAnonymousObject(propertyList) {
    var entity = blank();
    return {
      entity: entity,
      triples: propertyList.map(function (t) { return extend(triple(entity), t); })
    };
  }

  // Collects all (possibly blank) objects, and triples that have them as subject
  function objectListToTriples(predicate, objectList, otherTriples) {
    var objects = [], triples = [];
    objectList.forEach(function (l) {
      objects.push(triple(null, predicate, l.entity));
      appendAllTo(triples, l.triples);
    });
    return unionAll(objects, otherTriples || [], triples);
  }

  // Simplifies groups by merging adjacent BGPs
  function mergeAdjacentBGPs(groups) {
    var merged = [], currentBgp;
    for (var i = 0, group; group = groups[i]; i++) {
      switch (group.type) {
        // Add a BGP's triples to the current BGP
        case 'bgp':
          if (group.triples.length) {
            if (!currentBgp)
              appendTo(merged, currentBgp = group);
            else
              appendAllTo(currentBgp.triples, group.triples);
          }
          break;
        // All other groups break up a BGP
        default:
          // Only add the group if its pattern is non-empty
          if (!group.patterns || group.patterns.length > 0) {
            appendTo(merged, group);
            currentBgp = null;
          }
      }
    }
    return merged;
  }

  // Return the id of an expression
  function getExpressionId(expression) {
    return expression.variable ? expression.variable.value : expression.value || expression.expression.value;
  }

  // Get all "aggregate"'s from an expression
  function getAggregatesOfExpression(expression) {
    if (!expression) {
      return [];
    }
    if (expression.type === 'aggregate') {
      return [expression];
    } else if (expression.type === "operation") {
      const aggregates = [];
      for (const arg of expression.args) {
        aggregates.push(...getAggregatesOfExpression(arg));
      }
      return aggregates;
    }
    return [];
  }

  // Get all variables used in an expression
  function getVariablesFromExpression(expression) {
    const variables = new Set();
    const visitExpression = function (expr) {
      if (!expr) { return; }
      if (expr.termType === "Variable") {
        variables.add(expr);
      } else if (expr.type === "operation") {
        expr.args.forEach(visitExpression);
      }
    };
    visitExpression(expression);
    return variables;
  }

  // Helper function to flatten arrays
  function flatten(input, depth = 1, stack = []) {
    for (const item of input) {
        if (depth > 0 && item instanceof Array) {
          flatten(item, depth - 1, stack);
        } else {
          stack.push(item);
        }
    }
    return stack;
  }

  function isVariable(term) {
    return term.termType === 'Variable';
  }

  function getBoundVarsFromGroupGraphPattern(pattern) {
    if (pattern.triples) {
      const boundVars = [];
      for (const triple of pattern.triples) {
        if (isVariable(triple.subject)) boundVars.push(triple.subject.value);
        if (isVariable(triple.predicate)) boundVars.push(triple.predicate.value);
        if (isVariable(triple.object)) boundVars.push(triple.object.value);
      }
      return boundVars;
    } else if (pattern.patterns) {
      const boundVars = [];
      for (const pat of pattern.patterns) {
        boundVars.push(...getBoundVarsFromGroupGraphPattern(pat));
      }
      return boundVars;
    }
    return [];
  }

  // Helper function to find duplicates in array
  function getDuplicatesInArray(array) {
    const sortedArray = array.slice().sort();
    const duplicates = [];
    for (let i = 0; i < sortedArray.length - 1; i++) {
      if (sortedArray[i + 1] == sortedArray[i]) {
        duplicates.push(sortedArray[i]);
      }
    }
    return duplicates;
  }

  function ensureSparqlStar(value) {
    if (!Parser.sparqlStar) {
      throw new Error('SPARQL* support is not enabled');
    }
    return value;
  }

  function ensureNoVariables(operations) {
    for (const operation of operations) {
      if (operation.type === 'graph' && operation.name.termType === 'Variable') {
        throw new Error('Detected illegal variable in GRAPH');
      }
      if (operation.type === 'bgp' || operation.type === 'graph') {
        for (const triple of operation.triples) {
          if (triple.subject.termType === 'Variable' ||
              triple.predicate.termType === 'Variable' ||
              triple.object.termType === 'Variable') {
            throw new Error('Detected illegal variable in BGP');
          }
        }
      }
    }
    return operations;
  }

  function ensureNoBnodes(operations) {
    for (const operation of operations) {
      if (operation.type === 'bgp') {
        for (const triple of operation.triples) {
          if (triple.subject.termType === 'BlankNode' ||
              triple.predicate.termType === 'BlankNode' ||
              triple.object.termType === 'BlankNode') {
            throw new Error('Detected illegal blank node in BGP');
          }
        }
      }
    }
    return operations;
  }
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex () {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin (condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState (condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {"flex":true,"case-insensitive":true},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:/* ignore */
break;
case 1:return 12
break;
case 2:return 15
break;
case 3:return 28
break;
case 4:return 316
break;
case 5:return 317
break;
case 6:return 35
break;
case 7:return 37
break;
case 8:return 38
break;
case 9:return 26
break;
case 10:return 41
break;
case 11:return 45
break;
case 12:return 46
break;
case 13:return 48
break;
case 14:return 50
break;
case 15:return 55
break;
case 16:return 58
break;
case 17:return 320
break;
case 18:return 68
break;
case 19:return 69
break;
case 20:return 75
break;
case 21:return 78
break;
case 22:return 81
break;
case 23:return 83
break;
case 24:return 86
break;
case 25:return 88
break;
case 26:return 90
break;
case 27:return 191
break;
case 28:return 107
break;
case 29:return 321
break;
case 30:return 140
break;
case 31:return 322
break;
case 32:return 323
break;
case 33:return 117
break;
case 34:return 324
break;
case 35:return 116
break;
case 36:return 325
break;
case 37:return 326
break;
case 38:return 120
break;
case 39:return 122
break;
case 40:return 123
break;
case 41:return 138
break;
case 42:return 132
break;
case 43:return 133
break;
case 44:return 135
break;
case 45:return 141
break;
case 46:return 119
break;
case 47:return 327
break;
case 48:return 328
break;
case 49:return 167
break;
case 50:return 170
break;
case 51:return 174
break;
case 52:return 100
break;
case 53:return 168
break;
case 54:return 329
break;
case 55:return 173
break;
case 56:return 231
break;
case 57:return 235
break;
case 58:return 278
break;
case 59:return 195
break;
case 60:return 330
break;
case 61:return 331
break;
case 62:return 224
break;
case 63:return 333
break;
case 64:return 271
break;
case 65:return 219
break;
case 66:return 226
break;
case 67:return 227
break;
case 68:return 250
break;
case 69:return 254
break;
case 70:return 295
break;
case 71:return 334
break;
case 72:return 335
break;
case 73:return 336
break;
case 74:return 337
break;
case 75:return 338
break;
case 76:return 258
break;
case 77:return 339
break;
case 78:return 273
break;
case 79:return 281
break;
case 80:return 282
break;
case 81:return 275
break;
case 82:return 276
break;
case 83:return 277
break;
case 84:return 340
break;
case 85:return 341
break;
case 86:return 279
break;
case 87:return 343
break;
case 88:return 342
break;
case 89:return 344
break;
case 90:return 284
break;
case 91:return 285
break;
case 92:return 288
break;
case 93:return 290
break;
case 94:return 294
break;
case 95:return 298
break;
case 96:return 301
break;
case 97:return 13
break;
case 98:return 16
break;
case 99:return 312
break;
case 100:return 245
break;
case 101:return 34
break;
case 102:return 297
break;
case 103:return 87
break;
case 104:return 299
break;
case 105:return 300
break;
case 106:return 306
break;
case 107:return 307
break;
case 108:return 308
break;
case 109:return 309
break;
case 110:return 310
break;
case 111:return 311
break;
case 112:return 'EXPONENT'
break;
case 113:return 302
break;
case 114:return 303
break;
case 115:return 304
break;
case 116:return 305
break;
case 117:return 93
break;
case 118:return 246
break;
case 119:return 6
break;
case 120:return 'INVALID'
break;
case 121:console.log(yy_.yytext);
break;
}
},
rules: [/^(?:\s+|(#[^\n\r]*))/i,/^(?:BASE)/i,/^(?:PREFIX)/i,/^(?:SELECT)/i,/^(?:DISTINCT)/i,/^(?:REDUCED)/i,/^(?:\()/i,/^(?:AS)/i,/^(?:\))/i,/^(?:\*)/i,/^(?:CONSTRUCT)/i,/^(?:WHERE)/i,/^(?:\{)/i,/^(?:\})/i,/^(?:DESCRIBE)/i,/^(?:ASK)/i,/^(?:FROM)/i,/^(?:NAMED)/i,/^(?:GROUP)/i,/^(?:BY)/i,/^(?:HAVING)/i,/^(?:ORDER)/i,/^(?:ASC)/i,/^(?:DESC)/i,/^(?:LIMIT)/i,/^(?:OFFSET)/i,/^(?:VALUES)/i,/^(?:;)/i,/^(?:LOAD)/i,/^(?:SILENT)/i,/^(?:INTO)/i,/^(?:CLEAR)/i,/^(?:DROP)/i,/^(?:CREATE)/i,/^(?:ADD)/i,/^(?:TO)/i,/^(?:MOVE)/i,/^(?:COPY)/i,/^(?:INSERT((\s+|(#[^\n\r]*)\n\r?)+)DATA)/i,/^(?:DELETE((\s+|(#[^\n\r]*)\n\r?)+)DATA)/i,/^(?:DELETE((\s+|(#[^\n\r]*)\n\r?)+)WHERE)/i,/^(?:WITH)/i,/^(?:DELETE)/i,/^(?:INSERT)/i,/^(?:USING)/i,/^(?:DEFAULT)/i,/^(?:GRAPH)/i,/^(?:ALL)/i,/^(?:\.)/i,/^(?:OPTIONAL)/i,/^(?:SERVICE)/i,/^(?:BIND)/i,/^(?:UNDEF)/i,/^(?:MINUS)/i,/^(?:UNION)/i,/^(?:FILTER)/i,/^(?:<<)/i,/^(?:>>)/i,/^(?:,)/i,/^(?:a)/i,/^(?:\|)/i,/^(?:\/)/i,/^(?:\^)/i,/^(?:\?)/i,/^(?:\+)/i,/^(?:!)/i,/^(?:\[)/i,/^(?:\])/i,/^(?:\|\|)/i,/^(?:&&)/i,/^(?:=)/i,/^(?:!=)/i,/^(?:<)/i,/^(?:>)/i,/^(?:<=)/i,/^(?:>=)/i,/^(?:IN)/i,/^(?:NOT)/i,/^(?:-)/i,/^(?:BOUND)/i,/^(?:BNODE)/i,/^(?:(RAND|NOW|UUID|STRUUID))/i,/^(?:(LANG|DATATYPE|IRI|URI|ABS|CEIL|FLOOR|ROUND|STRLEN|STR|UCASE|LCASE|ENCODE_FOR_URI|YEAR|MONTH|DAY|HOURS|MINUTES|SECONDS|TIMEZONE|TZ|MD5|SHA1|SHA256|SHA384|SHA512|isIRI|isURI|isBLANK|isLITERAL|isNUMERIC))/i,/^(?:(LANGMATCHES|CONTAINS|STRSTARTS|STRENDS|STRBEFORE|STRAFTER|STRLANG|STRDT|sameTerm))/i,/^(?:CONCAT)/i,/^(?:COALESCE)/i,/^(?:IF)/i,/^(?:REGEX)/i,/^(?:SUBSTR)/i,/^(?:REPLACE)/i,/^(?:EXISTS)/i,/^(?:COUNT)/i,/^(?:SUM|MIN|MAX|AVG|SAMPLE)/i,/^(?:GROUP_CONCAT)/i,/^(?:SEPARATOR)/i,/^(?:\^\^)/i,/^(?:true|false)/i,/^(?:(<(?:[^<>\"\{\}\|\^`\\\u0000-\u0020])*>))/i,/^(?:((([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])(?:(?:(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040])|\.)*(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040]))?)?:))/i,/^(?:(((([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])(?:(?:(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040])|\.)*(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040]))?)?:)((?:((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|:|[0-9]|((%([0-9A-Fa-f])([0-9A-Fa-f]))|(\\(_|~|\.|-|!|\$|&|'|\(|\)|\*|\+|,|;|=|\/|\?|#|@|%))))(?:(?:(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040])|\.|:|((%([0-9A-Fa-f])([0-9A-Fa-f]))|(\\(_|~|\.|-|!|\$|&|'|\(|\)|\*|\+|,|;|=|\/|\?|#|@|%))))*(?:(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040])|:|((%([0-9A-Fa-f])([0-9A-Fa-f]))|(\\(_|~|\.|-|!|\$|&|'|\(|\)|\*|\+|,|;|=|\/|\?|#|@|%)))))?)))/i,/^(?:(_:(?:((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|[0-9])(?:(?:(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040])|\.)*(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040]))?))/i,/^(?:([\?\$]((?:((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|[0-9])(?:((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040])*)))/i,/^(?:(@[a-zA-Z]+(?:-[a-zA-Z0-9]+)*))/i,/^(?:([0-9]+))/i,/^(?:([0-9]*\.[0-9]+))/i,/^(?:([0-9]+\.[0-9]*([eE][+-]?[0-9]+)|\.([0-9])+([eE][+-]?[0-9]+)|([0-9])+([eE][+-]?[0-9]+)))/i,/^(?:(\+([0-9]+)))/i,/^(?:(\+([0-9]*\.[0-9]+)))/i,/^(?:(\+([0-9]+\.[0-9]*([eE][+-]?[0-9]+)|\.([0-9])+([eE][+-]?[0-9]+)|([0-9])+([eE][+-]?[0-9]+))))/i,/^(?:(-([0-9]+)))/i,/^(?:(-([0-9]*\.[0-9]+)))/i,/^(?:(-([0-9]+\.[0-9]*([eE][+-]?[0-9]+)|\.([0-9])+([eE][+-]?[0-9]+)|([0-9])+([eE][+-]?[0-9]+))))/i,/^(?:([eE][+-]?[0-9]+))/i,/^(?:('(?:(?:[^\u0027\u005C\u000A\u000D])|(\\[tbnrf\\\"']|\\u([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])|\\U([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])))*'))/i,/^(?:("(?:(?:[^\u0022\u005C\u000A\u000D])|(\\[tbnrf\\\"']|\\u([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])|\\U([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])))*"))/i,/^(?:('''(?:(?:'|'')?(?:[^'\\]|(\\[tbnrf\\\"']|\\u([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])|\\U([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f]))))*'''))/i,/^(?:("""(?:(?:"|"")?(?:[^\"\\]|(\\[tbnrf\\\"']|\\u([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])|\\U([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f]))))*"""))/i,/^(?:(\((\u0020|\u0009|\u000D|\u000A)*\)))/i,/^(?:(\[(\u0020|\u0009|\u000D|\u000A)*\]))/i,/^(?:$)/i,/^(?:.)/i,/^(?:.)/i],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();module.exports=SparqlParser


/***/ }),

/***/ 29511:
/***/ ((module) => {


// Wildcard constructor
class Wildcard {
  constructor() {
    return WILDCARD || this;
  }

  equals(other) {
    return other && (this.termType === other.termType);
  }
}

Object.defineProperty(Wildcard.prototype, 'value', {
  enumerable: true,
  value: '*',
});

Object.defineProperty(Wildcard.prototype, 'termType', {
  enumerable: true,
  value: 'Wildcard',
});


// Wildcard singleton
var WILDCARD = new Wildcard();

module.exports.R = Wildcard;


/***/ }),

/***/ 38711:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Parser = (__webpack_require__(5131).Parser);
var Generator = __webpack_require__(54870);
var Wildcard = (__webpack_require__(29511)/* .Wildcard */ .R);
var { DataFactory } = __webpack_require__(18628);

module.exports = {
  /**
   * Creates a SPARQL parser with the given pre-defined prefixes and base IRI
   * @param options {
   *   prefixes?: { [prefix: string]: string },
   *   baseIRI?: string,
   *   factory?: import('rdf-js').DataFactory,
   *   sparqlStar?: boolean,
   *   skipValidation?: boolean,
   *   skipUngroupedVariableCheck?: boolean
   * }
   */
  Parser: function ({ prefixes, baseIRI, factory, sparqlStar, skipValidation, skipUngroupedVariableCheck, pathOnly } = {}) {

    // Create a copy of the prefixes
    var prefixesCopy = {};
    for (var prefix in prefixes || {})
      prefixesCopy[prefix] = prefixes[prefix];

    // Create a new parser with the given prefixes
    // (Workaround for https://github.com/zaach/jison/issues/241)
    var parser = new Parser();
    parser.parse = function () {
      Parser.base = baseIRI || '';
      Parser.prefixes = Object.create(prefixesCopy);
      Parser.factory = factory || new DataFactory();
      Parser.sparqlStar = Boolean(sparqlStar);
      Parser.pathOnly = Boolean(pathOnly);
      // We keep skipUngroupedVariableCheck for compatibility reasons.
      Parser.skipValidation = Boolean(skipValidation) || Boolean(skipUngroupedVariableCheck)
      return Parser.prototype.parse.apply(parser, arguments);
    };
    parser._resetBlanks = Parser._resetBlanks;
    return parser;
  },
  Generator: Generator,
  Wildcard: Wildcard,
};


/***/ }),

/***/ 79397:
/***/ ((module) => {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ 64489:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



var isArgumentsObject = __webpack_require__(77092);
var isGeneratorFunction = __webpack_require__(97427);
var whichTypedArray = __webpack_require__(54010);
var isTypedArray = __webpack_require__(82527);

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});


/***/ }),

/***/ 85663:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(82530);
/* provided dependency */ var console = __webpack_require__(80292);
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').slice(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.slice(1, -1);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = __webpack_require__(64489);

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(79397);

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(48575);

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;


/***/ }),

/***/ 54010:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(94843);
var availableTypedArrays = __webpack_require__(14343);
var callBind = __webpack_require__(12550);
var callBound = __webpack_require__(97615);
var gOPD = __webpack_require__(93828);

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __webpack_require__(44111)();

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var cache = { __proto__: null };
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr) {
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			cache['$' + typedArray] = callBind(descriptor.get);
		}
	});
} else {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		cache['$' + typedArray] = callBind(arr.slice);
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var found = false;
	forEach(cache, function (getter, typedArray) {
		if (!found) {
			try {
				if ('$' + getter(value) === typedArray) {
					found = $slice(typedArray, 1);
				}
			} catch (e) { /**/ }
		}
	});
	return found;
};

var trySlices = function tryAllSlices(value) {
	var found = false;
	forEach(cache, function (getter, name) {
		if (!found) {
			try {
				getter(value);
				found = $slice(name, 1);
			} catch (e) { /**/ }
		}
	});
	return found;
};

module.exports = function whichTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag) {
		var tag = $slice($toString(value), 8, -1);
		if ($indexOf(typedArrays, tag) > -1) {
			return tag;
		}
		if (tag !== 'Object') {
			return false;
		}
		// node < 0.6 hits here on real Typed Arrays
		return trySlices(value);
	}
	if (!gOPD) { return null; } // unknown engine
	return tryTypedArrays(value);
};


/***/ }),

/***/ 1656:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "13a194ebead0c473b516.png";

/***/ }),

/***/ 12180:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "94a1cfc90856879051d2.png";

/***/ }),

/***/ 72749:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "3c3436b4c0dbe4b8ce30.png";

/***/ }),

/***/ 14343:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var possibleNames = [
	'BigInt64Array',
	'BigUint64Array',
	'Float32Array',
	'Float64Array',
	'Int16Array',
	'Int32Array',
	'Int8Array',
	'Uint16Array',
	'Uint32Array',
	'Uint8Array',
	'Uint8ClampedArray'
];

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;

module.exports = function availableTypedArrays() {
	var out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			497: 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";

// UNUSED EXPORTS: default

;// CONCATENATED MODULE: ./src/assets/logo.png
const logo_namespaceObject = __webpack_require__.p + "d3bca066aeb4d1456c58.png";
// EXTERNAL MODULE: ./node_modules/html-loader/dist/runtime/getUrl.js
var getUrl = __webpack_require__(44523);
var getUrl_default = /*#__PURE__*/__webpack_require__.n(getUrl);
;// CONCATENATED MODULE: ./src/assets/landing.md
// Imports

var ___HTML_LOADER_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(1656), __webpack_require__.b);
var ___HTML_LOADER_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(12180), __webpack_require__.b);
var ___HTML_LOADER_IMPORT_2___ = new URL(/* asset import */ __webpack_require__(72749), __webpack_require__.b);
// Module
var ___HTML_LOADER_REPLACEMENT_0___ = getUrl_default()(___HTML_LOADER_IMPORT_0___);
var ___HTML_LOADER_REPLACEMENT_1___ = getUrl_default()(___HTML_LOADER_IMPORT_1___);
var ___HTML_LOADER_REPLACEMENT_2___ = getUrl_default()(___HTML_LOADER_IMPORT_2___);
var code = "<h1 id=\"geodata-wizard\">GeoData Wizard</h1> <p>GeoData Wizard is een programma waarmee tabellen omgezet kunnen worden naar linked data.</p> <h2 id=\"hoe-werkt-de-geodata-wizard\">Hoe werkt de GeoData Wizard?</h2> <p>De GeoData Wizard stelt de gebruiker in staat om tabellen om te zetten naar linked data. Dit gebeurt aan de hand van de volgende 3 stappen:</p> <ul> <li>Stap 1: Upload</li> <li>Stap 2: Configure</li> <li>Stap 3: Publish</li> </ul> <h3 id=\"stap-1-upload\">Stap 1: Upload</h3> <p>GeoData Wizard kan bestanden in het CSV formaat inlezen. CSV staat voor &quot;Comma Separated Values&quot;. De meeste spreadsheet programma&#39;s (zoals MS Excel) en database programma&#39;s (zoals MS Access) hebben een standaard optie om data in dit formaat te exporteren.</p> <p>Wanneer het CSV bestand vanaf de harde schijf beschikbaar is kan het tijdens de &quot;Upload&quot; stap worden geselecteerd (Figuur 1).</p> <figure> <img src=\"" + ___HTML_LOADER_REPLACEMENT_0___ + "\"> <figcaption> Figuur 1 - De upload stap in de GeoData Wizard. </figcaption> </figure> <p>Wanneer geen eigen tabel voorhanden is kan ook gebruik worden gemaakt van een voorbeeld tabel door op &quot;example CSV file&quot; te klikken.</p> <h2 id=\"stap-2-configure\">Stap 2: Configure</h2> <p>Wanneer de data gepload is in de GeoData Wizard kunnen we de transformatie gaan configureren. Deze configuratie bestaat uit de volgende stappen (Figuur 2):</p> <ol> <li>Stel in welke kolom wordt gebruikt voor identificatie.</li> <li>Stel in wat het type is van de objecten die in de rijen worden beschreven.</li> <li>Stel in welke eigenschap bij welke kolom hoort.</li> <li>Stel in welke verrijking moet worden toegepast op de cellen.</li> </ol> <figure> <img src=\"" + ___HTML_LOADER_REPLACEMENT_1___ + "\"> <figcaption> Figuur 2 - De configuratie stap in de GeoData Wizard. Dit is waar de transformatie wordt ingesteld. </figcaption> </figure> <h2 id=\"stap-3-publish\">Stap 3: Publish</h2> <p>Wanneer de GeoData Wizard de transformatie heeft uitgevoerd wordt deze in de volgende formaten aangeboden:</p> <ul> <li>Download het verrijkte CSV bestand</li> <li>Download de gegenereerde linked data</li> <li>Download het RML script dat kan worden doorontwikkeld</li> </ul> <p>Daarnaast kan de data direct worden gepload naar de triple store van het Platform Linked Data Nederland (PLDN) of naar het Kadaster (Figuur 3).</p> <figure> <img src=\"" + ___HTML_LOADER_REPLACEMENT_2___ + "\"> <figcaption> Figuur 3 - De publicatie stap in de GeoData Wizard. </figcaption> </figure> <h2 id=\"waarom-linked-data\">Waarom linked data?</h2> <p>De kracht van linked data is dat datasets via het web aan elkaar kunnen worden gekoppeld. Bovendien worden in linked data standaarden toegepast waardoor de gegevens beter uitwisselbaar zijn. Neem een kijkje op <a href=\"https://www.pldn.nl/wiki/Wat_is_het\">de website van het Platform Linked Data Nederland</a> voor meer informatie over linked data.</p> ";
// Exports
/* harmony default export */ const landing = (code);
;// CONCATENATED MODULE: ./src/assets/kerken-nederland-geodatawizard.csv
const kerken_nederland_geodatawizard_namespaceObject = "Kerk,Straat,Huisnummer,Postcode,Woonplaats,Denominatie,BAG ID,Punt cordinaat\r\nMunsterkerk,Munsterplein,12,6041HD,Roermond,Rooms-Katholiek Kerkgenootschap in Nederland,0957100000260969,Point(5.9885077122575 51.19355309031)\r\nDe Grote of St. Bavokerk te Haarlem,Oude Groenmarkt,3,2011HL,Haarlem,Protestantse Kerk in Nederland: Protestantse Gemeente,0392100000037432,Point(4.6367852414904 52.380867128717)\r\nPlein Kerk,Plein,27,3991DL,Houten,Hersteld Hervormde Kerk,0321100000006718,Point(5.1617524367345 52.027577800006)\r\nLutherse Kerk,Hondstraat,6,6211HX,Maastricht,Pinkstergemeente,0935100000019820,Point(5.6912975823322 50.847527370354)\r\nDoopsgezind Amsterdam,Singel,452,1017AW,Amsterdam,Algemene Doopsgezinde Sociteit,0363100012177610,Point(4.888625965831 52.367707869405)\r\nOud-katholieke Parochie vd H.H Jacobus en Augustinus,Juffrouw Idastraat,7,2513BE,s-Gravenhage,Oud-Katholieke Kerk van Nederland,0518100000307537,Point(4.3061896277919 52.079387625716)\r\nPieterskerk,Pieterskerkhof,5,3512JR,Utrecht,Christian Science Nederland & School voor openbaar basisonderwijs,0344100000034484,Point(5.1245520254649 52.091139138425)\r\nOude Kerk Oosterbeek,Benedendorpseweg,134,6862WP,Oosterbeek,Protestantse Kerk in Nederland: Protestantse Gemeente,0274100000000610,Point(5.8377785440148 51.977972075089)\r\n";
;// CONCATENATED MODULE: ./node_modules/@pldn/ldwizard/node_modules/n3/src/IRIs.js
const RDF  = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
    XSD  = 'http://www.w3.org/2001/XMLSchema#',
    SWAP = 'http://www.w3.org/2000/10/swap/';

/* harmony default export */ const IRIs = ({
  xsd: {
    decimal: `${XSD}decimal`,
    boolean: `${XSD}boolean`,
    double:  `${XSD}double`,
    integer: `${XSD}integer`,
    string:  `${XSD}string`,
  },
  rdf: {
    type:       `${RDF}type`,
    nil:        `${RDF}nil`,
    first:      `${RDF}first`,
    rest:       `${RDF}rest`,
    langString: `${RDF}langString`,
  },
  owl: {
    sameAs: 'http://www.w3.org/2002/07/owl#sameAs',
  },
  r: {
    forSome: `${SWAP}reify#forSome`,
    forAll:  `${SWAP}reify#forAll`,
  },
  log: {
    implies: `${SWAP}log#implies`,
  },
});

;// CONCATENATED MODULE: ./node_modules/@pldn/ldwizard/node_modules/n3/src/N3DataFactory.js
// N3.js implementations of the RDF/JS core data types
// See https://github.com/rdfjs/representation-task-force/blob/master/interface-spec.md



const { rdf, xsd } = IRIs;

// eslint-disable-next-line prefer-const
let DEFAULTGRAPH;
let _blankNodeCounter = 0;

const escapedLiteral = /^"(.*".*)(?="[^"]*$)/;
const quadId = /^<<("(?:""|[^"])*"[^ ]*|[^ ]+) ("(?:""|[^"])*"[^ ]*|[^ ]+) ("(?:""|[^"])*"[^ ]*|[^ ]+) ?("(?:""|[^"])*"[^ ]*|[^ ]+)?>>$/;

// ## DataFactory singleton
const DataFactory = {
  namedNode,
  blankNode,
  variable,
  literal,
  defaultGraph,
  quad,
  triple: quad,
};
/* harmony default export */ const N3DataFactory = (DataFactory);

// ## Term constructor
class Term {
  constructor(id) {
    this.id = id;
  }

  // ### The value of this term
  get value() {
    return this.id;
  }

  // ### Returns whether this object represents the same term as the other
  equals(other) {
    // If both terms were created by this library,
    // equality can be computed through ids
    if (other instanceof Term)
      return this.id === other.id;
    // Otherwise, compare term type and value
    return !!other && this.termType === other.termType &&
                      this.value    === other.value;
  }

  // ### Implement hashCode for Immutable.js, since we implement `equals`
  // https://immutable-js.com/docs/v4.0.0/ValueObject/#hashCode()
  hashCode() {
    return 0;
  }

  // ### Returns a plain object representation of this term
  toJSON() {
    return {
      termType: this.termType,
      value:    this.value,
    };
  }
}


// ## NamedNode constructor
class NamedNode extends Term {
  // ### The term type of this term
  get termType() {
    return 'NamedNode';
  }
}

// ## Literal constructor
class Literal extends Term {
  // ### The term type of this term
  get termType() {
    return 'Literal';
  }

  // ### The text value of this literal
  get value() {
    return this.id.substring(1, this.id.lastIndexOf('"'));
  }

  // ### The language of this literal
  get language() {
    // Find the last quotation mark (e.g., '"abc"@en-us')
    const id = this.id;
    let atPos = id.lastIndexOf('"') + 1;
    // If "@" it follows, return the remaining substring; empty otherwise
    return atPos < id.length && id[atPos++] === '@' ? id.substr(atPos).toLowerCase() : '';
  }

  // ### The datatype IRI of this literal
  get datatype() {
    return new NamedNode(this.datatypeString);
  }

  // ### The datatype string of this literal
  get datatypeString() {
    // Find the last quotation mark (e.g., '"abc"^^http://ex.org/types#t')
    const id = this.id, dtPos = id.lastIndexOf('"') + 1;
    const char = dtPos < id.length ? id[dtPos] : '';
    // If "^" it follows, return the remaining substring
    return char === '^' ? id.substr(dtPos + 2) :
           // If "@" follows, return rdf:langString; xsd:string otherwise
           (char !== '@' ? xsd.string : rdf.langString);
  }

  // ### Returns whether this object represents the same term as the other
  equals(other) {
    // If both literals were created by this library,
    // equality can be computed through ids
    if (other instanceof Literal)
      return this.id === other.id;
    // Otherwise, compare term type, value, language, and datatype
    return !!other && !!other.datatype &&
                      this.termType === other.termType &&
                      this.value    === other.value    &&
                      this.language === other.language &&
                      this.datatype.value === other.datatype.value;
  }

  toJSON() {
    return {
      termType: this.termType,
      value:    this.value,
      language: this.language,
      datatype: { termType: 'NamedNode', value: this.datatypeString },
    };
  }
}

// ## BlankNode constructor
class BlankNode extends Term {
  constructor(name) {
    super(`_:${name}`);
  }

  // ### The term type of this term
  get termType() {
    return 'BlankNode';
  }

  // ### The name of this blank node
  get value() {
    return this.id.substr(2);
  }
}

class Variable extends Term {
  constructor(name) {
    super(`?${name}`);
  }

  // ### The term type of this term
  get termType() {
    return 'Variable';
  }

  // ### The name of this variable
  get value() {
    return this.id.substr(1);
  }
}

// ## DefaultGraph constructor
class DefaultGraph extends Term {
  constructor() {
    super('');
    return DEFAULTGRAPH || this;
  }

  // ### The term type of this term
  get termType() {
    return 'DefaultGraph';
  }

  // ### Returns whether this object represents the same term as the other
  equals(other) {
    // If both terms were created by this library,
    // equality can be computed through strict equality;
    // otherwise, compare term types.
    return (this === other) || (!!other && (this.termType === other.termType));
  }
}

// ## DefaultGraph singleton
DEFAULTGRAPH = new DefaultGraph();


// ### Constructs a term from the given internal string ID
function termFromId(id, factory) {
  factory = factory || DataFactory;

  // Falsy value or empty string indicate the default graph
  if (!id)
    return factory.defaultGraph();

  // Identify the term type based on the first character
  switch (id[0]) {
  case '?':
    return factory.variable(id.substr(1));
  case '_':
    return factory.blankNode(id.substr(2));
  case '"':
    // Shortcut for internal literals
    if (factory === DataFactory)
      return new Literal(id);
    // Literal without datatype or language
    if (id[id.length - 1] === '"')
      return factory.literal(id.substr(1, id.length - 2));
    // Literal with datatype or language
    const endPos = id.lastIndexOf('"', id.length - 1);
    return factory.literal(id.substr(1, endPos - 1),
            id[endPos + 1] === '@' ? id.substr(endPos + 2)
                                   : factory.namedNode(id.substr(endPos + 3)));
  case '<':
    const components = quadId.exec(id);
    return factory.quad(
      termFromId(unescapeQuotes(components[1]), factory),
      termFromId(unescapeQuotes(components[2]), factory),
      termFromId(unescapeQuotes(components[3]), factory),
      components[4] && termFromId(unescapeQuotes(components[4]), factory)
    );
  default:
    return factory.namedNode(id);
  }
}

// ### Constructs an internal string ID from the given term or ID string
function termToId(term) {
  if (typeof term === 'string')
    return term;
  if (term instanceof Term && term.termType !== 'Quad')
    return term.id;
  if (!term)
    return DEFAULTGRAPH.id;

  // Term instantiated with another library
  switch (term.termType) {
  case 'NamedNode':    return term.value;
  case 'BlankNode':    return `_:${term.value}`;
  case 'Variable':     return `?${term.value}`;
  case 'DefaultGraph': return '';
  case 'Literal':      return `"${term.value}"${
    term.language ? `@${term.language}` :
      (term.datatype && term.datatype.value !== xsd.string ? `^^${term.datatype.value}` : '')}`;
  case 'Quad':
    // To identify RDF* quad components, we escape quotes by doubling them.
    // This avoids the overhead of backslash parsing of Turtle-like syntaxes.
    return `<<${
        escapeQuotes(termToId(term.subject))
      } ${
        escapeQuotes(termToId(term.predicate))
      } ${
        escapeQuotes(termToId(term.object))
      }${
        (isDefaultGraph(term.graph)) ? '' : ` ${termToId(term.graph)}`
      }>>`;
  default: throw new Error(`Unexpected termType: ${term.termType}`);
  }
}


// ## Quad constructor
class Quad extends Term {
  constructor(subject, predicate, object, graph) {
    super('');
    this._subject   = subject;
    this._predicate = predicate;
    this._object    = object;
    this._graph     = graph || DEFAULTGRAPH;
  }

  // ### The term type of this term
  get termType() {
    return 'Quad';
  }

  get subject() {
    return this._subject;
  }

  get predicate() {
    return this._predicate;
  }

  get object() {
    return this._object;
  }

  get graph() {
    return this._graph;
  }

  // ### Returns a plain object representation of this quad
  toJSON() {
    return {
      termType:  this.termType,
      subject:   this._subject.toJSON(),
      predicate: this._predicate.toJSON(),
      object:    this._object.toJSON(),
      graph:     this._graph.toJSON(),
    };
  }

  // ### Returns whether this object represents the same quad as the other
  equals(other) {
    return !!other && this._subject.equals(other.subject)     &&
                      this._predicate.equals(other.predicate) &&
                      this._object.equals(other.object)       &&
                      this._graph.equals(other.graph);
  }
}


// ### Escapes the quotes within the given literal
function escapeQuotes(id) {
  return id.replace(escapedLiteral, (_, quoted) => `"${quoted.replace(/"/g, '""')}`);
}

// ### Unescapes the quotes within the given literal
function unescapeQuotes(id) {
  return id.replace(escapedLiteral, (_, quoted) => `"${quoted.replace(/""/g, '"')}`);
}

// ### Creates an IRI
function namedNode(iri) {
  return new NamedNode(iri);
}

// ### Creates a blank node
function blankNode(name) {
  return new BlankNode(name || `n3-${_blankNodeCounter++}`);
}

// ### Creates a literal
function literal(value, languageOrDataType) {
  // Create a language-tagged string
  if (typeof languageOrDataType === 'string')
    return new Literal(`"${value}"@${languageOrDataType.toLowerCase()}`);

  // Automatically determine datatype for booleans and numbers
  let datatype = languageOrDataType ? languageOrDataType.value : '';
  if (datatype === '') {
    // Convert a boolean
    if (typeof value === 'boolean')
      datatype = xsd.boolean;
    // Convert an integer or double
    else if (typeof value === 'number') {
      if (Number.isFinite(value))
        datatype = Number.isInteger(value) ? xsd.integer : xsd.double;
      else {
        datatype = xsd.double;
        if (!Number.isNaN(value))
          value = value > 0 ? 'INF' : '-INF';
      }
    }
  }

  // Create a datatyped literal
  return (datatype === '' || datatype === xsd.string) ?
    new Literal(`"${value}"`) :
    new Literal(`"${value}"^^${datatype}`);
}

// ### Creates a variable
function variable(name) {
  return new Variable(name);
}

// ### Returns the default graph
function defaultGraph() {
  return DEFAULTGRAPH;
}

// ### Creates a quad
function quad(subject, predicate, object, graph) {
  return new Quad(subject, predicate, object, graph);
}

// EXTERNAL MODULE: ./node_modules/sparqljs/sparql.js
var sparql = __webpack_require__(38711);
;// CONCATENATED MODULE: ./node_modules/@pldn/ldwizard/src/utils/bulkSparql.js


const { Parser, Generator } = sparql;
const isVariable = (val) => {
    return typeof val === 'object' &&
        Object.keys(val).includes('termType') &&
        val.termType === 'Variable' &&
        Object.keys(val).includes('value');
};
async function bulkSparql(query, values, opts) {
    const request = {
        method: 'POST',
        headers: {
            Accept: "application/sparql-results+json",
            "Content-Type": "application/x-www-form-urlencoded",
            ...opts.request?.headers ?? {}
        },
        ...opts.request ?? {}
    };
    const optsWithDefault = {
        transformedValueName: 'transformed',
        request,
        searchValueName: 'searchValue',
        batchSize: 0,
        transformer: (value) => N3DataFactory.literal(value),
        ...opts
    };
    const parsed = (new Parser()).parse(query);
    // check if the query is a select query
    if (parsed.type !== 'query') {
        throw new Error(`Unexpected query type '${parsed.type}', expected 'query'`);
    }
    if (parsed.queryType !== 'SELECT') {
        throw new Error(`Unexpected query type '${parsed.queryType}', expected 'SELECT'`);
    }
    // the transformedValue must be in the bindings:
    let found = false;
    for (const variable of parsed.variables) {
        if (isVariable(variable) && variable.value === optsWithDefault.transformedValueName) {
            found = true;
        }
    }
    if (!found) {
        throw new Error(`Expected variable '${optsWithDefault.transformedValueName}' to be in the result bindings but it is not.`);
    }
    // remove the prefixes from the query template, we need to add them later in the union query:
    const prefixes = Object.keys(parsed.prefixes).map(prefix => `prefix ${prefix}: <${parsed.prefixes[prefix]}>`).join('\n');
    parsed.prefixes = {};
    // for each resultset, we only want the first one
    parsed.limit = 1;
    const where = parsed.where ?? [];
    const variables = parsed.variables ?? [];
    // make sure the variable name is prependend by a '?':
    const searchValueName = '?' + optsWithDefault.searchValueName.replace(/^\?/, '');
    // here we will store all the individual queries
    const union = [];
    // here we will store all transformed values:
    const enriched = values.map(_ => '');
    function buildUnionQuery() {
        return `${prefixes}\nselect ?${optsWithDefault.transformedValueName} ?rowIx where {\n${union.join("\nunion\n")}\n}`;
    }
    let rowIx = 0;
    for (const value of values) {
        // add the rownumber to the bindings:
        const row = {
            expression: N3DataFactory.literal(rowIx, N3DataFactory.namedNode('https://www.w3.org/2001/XMLSchema#integer')),
            variable: N3DataFactory.variable('rowIx')
        };
        // @ts-ignore
        parsed.variables = [...variables, row];
        // inject the searchValue as a SPARQL value:
        parsed.where = [
            ...where,
            { type: 'values', values: [{ [searchValueName]: optsWithDefault.transformer(value) }] }
        ];
        union.push(`\n###### row ${rowIx} ######\n{\n${(new Generator()).stringify(parsed)}\n}`);
        if (optsWithDefault.batchSize !== undefined && optsWithDefault.batchSize > 0 && ((rowIx - 1) % optsWithDefault.batchSize) === 0) {
            // perform the query:
            await executeQuery(buildUnionQuery(), enriched, optsWithDefault);
            union.length = 0;
        }
        rowIx++;
    }
    if (union.length > 0) {
        // perform the query:
        await executeQuery(buildUnionQuery(), enriched, optsWithDefault);
    }
    // return the enriched values:
    return enriched;
}
async function executeQuery(query, enriched, opts) {
    const body = 'query=' + encodeURIComponent(query);
    return fetch(opts.sparqlEndpoint, { ...opts.request, body })
        .then(res => res.json())
        .then(res => res.results.bindings)
        .then(bindings => {
        for (const binding of bindings) {
            const transformed = binding[opts.transformedValueName];
            enriched[parseInt(binding.rowIx.value)] = transformed.value;
        }
        return enriched;
    });
}

;// CONCATENATED MODULE: ./src/transformations/index.ts
/* provided dependency */ var console = __webpack_require__(80292);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return { value: void 0, done: !0 }; } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable || "" === iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } throw new TypeError(_typeof(iterable) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var van_bag_id_naar_kkg_iri = {
  type: "single",
  label: "Van BAG code naar Kadaster Knowledge Graph IRI",
  description: "Gebruikt een kolom met codes die in de Basisregistratie Adressen en Gebouwen (BAG) voorkomen, en vindt de corresponderende IRI in de Kadaster Knowledge Graph. De volgende BAG codes worden ondersteund: nummeraanduiding code, openbare ruimte code, pand code, verblijfsobject code, woonplaats code. Voor meer informatie over de Kadaster Knowledge Graph, zie https://data.kkg.kadaster.nl",
  transformation: function () {
    var _transformation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(id) {
      var url, _results$, results;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            url = "https://api.labs.kadaster.nl/queries/GeoData-Wizard/van-bag-id-naar-kkg-iri/run?id=".concat(id);
            _context.prev = 1;
            _context.next = 4;
            return fetchCall(url);
          case 4:
            results = _context.sent;
            if (!(results.length === 0)) {
              _context.next = 8;
              break;
            }
            console.warn("No results found for refinement query.");
            return _context.abrupt("return", undefined);
          case 8:
            return _context.abrupt("return", results === null || results === void 0 || (_results$ = results[0]) === null || _results$ === void 0 ? void 0 : _results$.iri);
          case 11:
            _context.prev = 11;
            _context.t0 = _context["catch"](1);
            console.error(_context.t0);
            return _context.abrupt("return", undefined);
          case 15:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[1, 11]]);
    }));
    function transformation(_x) {
      return _transformation.apply(this, arguments);
    }
    return transformation;
  }(),
  yieldsIri: true,
  keepOriginalValue: {
    keepValue: true,
    owlSameAsRelationship: true
  }
};
var van_wkt_punt_naar_kkg_gebouw = {
  type: "single",
  label: "Van punt cordinaat naar Kadaster Knowledge Graph gebouw IRI",
  description: 'Gebruikt een kolom met punt cordinaten in het Well-Known Text (WKT) formaat, en vindt de corresponderende gebouw IRI in de Kadaster Knowledge Graph. Een punt in het WKT formaat ziet er als volgt uit: "Point (5.95996114188 52.1796098569)" Voor meer informatie over de Kadaster Knowledge Graph, zie https://data.kkg.kadaster.nl',
  transformation: function () {
    var _transformation2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(punt) {
      var url, _results$2, results;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            url = "https://api.labs.kadaster.nl/queries/GeoData-Wizard/van-wkt-punt-naar-kkg-gebouw/run?punt=".concat(punt);
            _context2.prev = 1;
            _context2.next = 4;
            return fetchCall(url);
          case 4:
            results = _context2.sent;
            if (!(results.length === 0)) {
              _context2.next = 8;
              break;
            }
            console.warn("No results found for refinement query.");
            return _context2.abrupt("return", undefined);
          case 8:
            return _context2.abrupt("return", results === null || results === void 0 || (_results$2 = results[0]) === null || _results$2 === void 0 ? void 0 : _results$2.iri);
          case 11:
            _context2.prev = 11;
            _context2.t0 = _context2["catch"](1);
            console.error(_context2.t0);
            return _context2.abrupt("return", undefined);
          case 15:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[1, 11]]);
    }));
    function transformation(_x2) {
      return _transformation2.apply(this, arguments);
    }
    return transformation;
  }(),
  yieldsIri: true,
  keepOriginalValue: {
    keepValue: true,
    owlSameAsRelationship: true,
    customPredicateIRI: "https://data.kkg.kadaster.nl/def/kkg-gebouw",
    keepAsLiteral: true // in de owl:sameAs relatie zal de oorsporonkelijke punt cordinaat als literal worden behouden 
  }
};

var van_wkt_punt_naar_kkg_perceel = {
  type: "single",
  label: "Van punt cordinaat naar Kadaster Knowledge Graph perceel IRI",
  description: 'Gebruikt een kolom met punt cordinaten in het Well-Known Text (WKT) formaat, en vindt de corresponderende perceel IRI in de Kadaster Knowledge Graph. Een punt in het WKT formaat ziet er als volgt uit: "Point (5.95996114188 52.1796098569)" Voor meer informatie over de Kadaster Knowledge Graph, zie https://data.kkg.kadaster.nl',
  transformation: function () {
    var _transformation3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(punt) {
      var url, _results$3, results;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            url = "https://api.labs.kadaster.nl/queries/GeoData-Wizard/van-wkt-punt-naar-kkg-perceel/run?punt=".concat(punt);
            _context3.prev = 1;
            _context3.next = 4;
            return fetchCall(url);
          case 4:
            results = _context3.sent;
            if (!(results.length === 0)) {
              _context3.next = 8;
              break;
            }
            console.warn("No results found for refinement query.");
            return _context3.abrupt("return", undefined);
          case 8:
            return _context3.abrupt("return", results === null || results === void 0 || (_results$3 = results[0]) === null || _results$3 === void 0 ? void 0 : _results$3.iri);
          case 11:
            _context3.prev = 11;
            _context3.t0 = _context3["catch"](1);
            console.error(_context3.t0);
            return _context3.abrupt("return", undefined);
          case 15:
          case "end":
            return _context3.stop();
        }
      }, _callee3, null, [[1, 11]]);
    }));
    function transformation(_x3) {
      return _transformation3.apply(this, arguments);
    }
    return transformation;
  }(),
  yieldsIri: true,
  keepOriginalValue: {
    keepValue: true,
    owlSameAsRelationship: true,
    customPredicateIRI: "https://data.kkg.kadaster.nl/def/perceel",
    keepAsLiteral: true // in de owl:sameAs relatie zal de oorsporonkelijke punt cordinaat als literal worden behouden 
  }
};

var van_bag_pand_id_naar_kkg_geometrie = {
  type: "single",
  label: "Van BAG pand code naar geometrie",
  description: "Gebruikt een kolom met pand codes die in de Basisregistratie Adressen en Gebouwen (BAG) voorkomen, en vindt de corresponderende geometrie in de Kadaster Knowledge Graph. Voor meer informatie over de Kadaster Knowledge Graph, zie https://data.kkg.kadaster.nl",
  transformation: function () {
    var _transformation4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(id) {
      var url, _results$4, results, polygon;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            url = "https://api.labs.kadaster.nl/queries/GeoData-Wizard/bag-geometrie/run?id=".concat(id);
            _context4.prev = 1;
            _context4.next = 4;
            return fetchCall(url);
          case 4:
            results = _context4.sent;
            if (!(results.length === 0)) {
              _context4.next = 8;
              break;
            }
            console.warn("No results found for refinement query.");
            return _context4.abrupt("return", undefined);
          case 8:
            polygon = results === null || results === void 0 || (_results$4 = results[0]) === null || _results$4 === void 0 ? void 0 : _results$4.wkt;
            return _context4.abrupt("return", polygon);
          case 12:
            _context4.prev = 12;
            _context4.t0 = _context4["catch"](1);
            console.error(_context4.t0);
            return _context4.abrupt("return", undefined);
          case 16:
          case "end":
            return _context4.stop();
        }
      }, _callee4, null, [[1, 12]]);
    }));
    function transformation(_x4) {
      return _transformation4.apply(this, arguments);
    }
    return transformation;
  }(),
  yieldsLiteral: true,
  keepOriginalValue: {
    keepValue: true,
    owlSameAsRelationship: true,
    customPredicateIRI: "https://data.kkg.kadaster.nl/def/geometrie"
  }
};
var pdok_locatie_server = "https://api.pdok.nl/bzk/locatieserver/search/v3_1/free?fq=bron:BAG&q=";
var van_adres_en_woonplaats_naar_kkg_openbareRuimte = {
  type: "double-column",
  label: "Van straatnaam + woonplaats naam naar Kadaster Knowledge Graph openbare ruimte IRI",
  description: "Gebruikt deze kolom met straatnamen en een tweede kolom met woonplaats namen, en vindt de corresponderende IRI in de Kadaster Knowledge Graph. Voor meer informatie over de Kadaster Knowledge Graph, zie https://data.kkg.kadaster.nl",
  transformation: function () {
    var _transformation5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(straat, woonplaats) {
      var _response$response$do;
      var response, id;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return fetchCall("".concat(pdok_locatie_server).concat(straat, " ").concat(woonplaats));
          case 2:
            response = _context5.sent;
            id = (_response$response$do = response.response.docs[0]) === null || _response$response$do === void 0 ? void 0 : _response$response$do.openbareruimte_id;
            if (!(id === undefined)) {
              _context5.next = 9;
              break;
            }
            console.warn("No results found for refinement query.");
            return _context5.abrupt("return", undefined);
          case 9:
            return _context5.abrupt("return", "https://data.kkg.kadaster.nl/id/openbareRuimte/".concat(id));
          case 10:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }));
    function transformation(_x5, _x6) {
      return _transformation5.apply(this, arguments);
    }
    return transformation;
  }(),
  yieldsIri: true,
  keepOriginalValue: {
    keepValue: true,
    owlSameAsRelationship: false,
    customPredicateIRI: "https://data.kkg.kadaster.nl/def/openbareRuimte"
  }
};
var van_postcode_en_huisnummer_naar_kkg_nummeraanduiding = {
  type: "double-column",
  label: "Van postcode + huisnummer naar Kadaster Knowledge Graph nummeraanduiding IRI",
  description: "Gebruikt deze kolom met postcodes en een tweede kolom met huisnummers, en vindt de corresponderende IRI in de Kadaster Knowledge Graph. Voor meer informatie over de Kadaster Knowledge Graph, zie https://data.kkg.kadaster.nl",
  transformation: function () {
    var _transformation6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(postcode, huisnummer) {
      var _response$response$do2;
      var response, id;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return fetchCall("".concat(pdok_locatie_server).concat(postcode, " ").concat(huisnummer));
          case 2:
            response = _context6.sent;
            id = (_response$response$do2 = response.response.docs[0]) === null || _response$response$do2 === void 0 ? void 0 : _response$response$do2.nummeraanduiding_id;
            if (!(id === undefined)) {
              _context6.next = 9;
              break;
            }
            console.warn("No results found for refinement query.");
            return _context6.abrupt("return", undefined);
          case 9:
            return _context6.abrupt("return", "https://data.kkg.kadaster.nl/id/nummeraanduiding/".concat(id));
          case 10:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    }));
    function transformation(_x7, _x8) {
      return _transformation6.apply(this, arguments);
    }
    return transformation;
  }(),
  yieldsIri: true,
  keepOriginalValue: {
    keepValue: true,
    owlSameAsRelationship: false,
    customPredicateIRI: "https://data.kkg.kadaster.nl/def/nummeraanduiding"
  }
};
var van_woonplaats_naar_kkg_woonplaats = {
  type: "single",
  label: "Van woonplaats naam naar Kadaster Knowledge Graph woonplaats IRI",
  description: "Gebruikt de woonplaats namen in deze kolom, en vindt de corresponderende IRI in de Kadaster Knowledge Graph. Voor meer informatie over de Kadaster Knowledge Graph, zie https://data.kkg.kadaster.nl",
  transformation: function () {
    var _transformation7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(woonplaats) {
      var _response$response$do3, response, id;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            _context7.prev = 0;
            _context7.next = 3;
            return fetchCall("".concat(pdok_locatie_server).concat(woonplaats));
          case 3:
            response = _context7.sent;
            id = (_response$response$do3 = response.response.docs[0]) === null || _response$response$do3 === void 0 ? void 0 : _response$response$do3.woonplaatscode;
            if (!(id === undefined)) {
              _context7.next = 10;
              break;
            }
            console.warn("No results found for refinement query.");
            return _context7.abrupt("return", undefined);
          case 10:
            return _context7.abrupt("return", "https://data.kkg.kadaster.nl/id/woonplaats/".concat(id));
          case 11:
            _context7.next = 17;
            break;
          case 13:
            _context7.prev = 13;
            _context7.t0 = _context7["catch"](0);
            console.error(_context7.t0);
            return _context7.abrupt("return", undefined);
          case 17:
          case "end":
            return _context7.stop();
        }
      }, _callee7, null, [[0, 13]]);
    }));
    function transformation(_x9) {
      return _transformation7.apply(this, arguments);
    }
    return transformation;
  }(),
  yieldsIri: true,
  keepOriginalValue: {
    keepValue: true,
    owlSameAsRelationship: true,
    customPredicateIRI: "https://data.kkg.kadaster.nl/def/woonplaats"
  }
};
function fetchCall(_x10) {
  return _fetchCall.apply(this, arguments);
} // Dit is een voorbeeld van de nieuwe SPARQL bulk processing feature:
function _fetchCall() {
  _fetchCall = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(request) {
    var response, jsonResponse;
    return _regeneratorRuntime().wrap(function _callee9$(_context9) {
      while (1) switch (_context9.prev = _context9.next) {
        case 0:
          console.log("API request to: ", request);
          _context9.next = 3;
          return fetch(request, {
            method: 'GET'
          });
        case 3:
          response = _context9.sent;
          if (response.ok) {
            _context9.next = 8;
            break;
          }
          throw new Error("".concat(request, " returned ").concat(response.status));
        case 8:
          _context9.next = 10;
          return response.json();
        case 10:
          jsonResponse = _context9.sent;
          console.log("fetchCall Json Response: ", jsonResponse);
          return _context9.abrupt("return", jsonResponse);
        case 13:
        case "end":
          return _context9.stop();
      }
    }, _callee9);
  }));
  return _fetchCall.apply(this, arguments);
}
var van_bag_pand_id_naar_kkg_geometrie_bulk = {
  label: "Van BAG pand code naar geometrie (bulk verwerking)",
  type: "single",
  description: "Gebruikt een kolom met pand codes die in de Basisregistratie Adressen en Gebouwen (BAG) voorkomen, en vindt de corresponderende geometrie in de Kadaster Knowledge Graph. Voor meer informatie over de Kadaster Knowledge Graph, zie https://data.kkg.kadaster.nl",
  batchSize: 100,
  bulkTransformation: function () {
    var _bulkTransformation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(bagIds) {
      var queryString, sparqlEndpoint, options;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            // make sure to not use blanknodes in the SPARQL query!
            queryString = "\nprefix bag: <http://bag.basisregistraties.overheid.nl/def/bag#>\nprefix geo: <http://www.opengis.net/ont/geosparql#>\nprefix nen3610: <https://data.kkg.kadaster.nl/nen3610/model/def/>\nprefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nprefix sor: <https://data.kkg.kadaster.nl/sor/model/def/>\nselect ?wkt {\n  ?gebouw a sor:Gebouw;\n     geo:hasGeometry ?geometry ;\n     sor:geregistreerdMet/nen3610:identificatie ?id.\n  ?geometry rdfs:isDefinedBy bag: ; geo:asWKT ?wkt ;\n}";
            sparqlEndpoint = 'https://api.labs.kadaster.nl/datasets/dst/kkg/services/default/sparql';
            options = {
              sparqlEndpoint: sparqlEndpoint,
              searchValueName: 'id',
              transformedValueName: 'wkt'
            };
            return _context8.abrupt("return", bulkSparql(queryString, bagIds, options));
          case 4:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    }));
    function bulkTransformation(_x11) {
      return _bulkTransformation.apply(this, arguments);
    }
    return bulkTransformation;
  }(),
  yieldsLiteral: true,
  keepOriginalValue: {
    keepValue: true,
    owlSameAsRelationship: true,
    customPredicateIRI: "https://data.kkg.kadaster.nl/def/geometrie"
  }
};
;// CONCATENATED MODULE: ./src/config.ts
function config_typeof(obj) { "@babel/helpers - typeof"; return config_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, config_typeof(obj); }
function config_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ config_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == config_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return { value: void 0, done: !0 }; } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable || "" === iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } throw new TypeError(config_typeof(iterable) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function config_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function config_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { config_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { config_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




var elasticsearchEndpoint = 'https://api.labs.kadaster.nl/datasets/GeoData-Wizard/vocabulaires/services/search/elasticsearch/';
var wizardConfig = {
  appName: 'GeoData Wizard',
  classConfig: {
    method: 'elastic',
    endpoint: elasticsearchEndpoint
  },
  columnRefinements: [van_bag_id_naar_kkg_iri, van_wkt_punt_naar_kkg_gebouw, van_wkt_punt_naar_kkg_perceel, van_woonplaats_naar_kkg_woonplaats, van_postcode_en_huisnummer_naar_kkg_nummeraanduiding, van_adres_en_woonplaats_naar_kkg_openbareRuimte, van_bag_pand_id_naar_kkg_geometrie, van_bag_pand_id_naar_kkg_geometrie_bulk],
  dataplatformLink: 'https://data.pldn.nl',
  defaultBaseIri: 'https://data.pldn.nl/',
  exampleCSV: kerken_nederland_geodatawizard_namespaceObject,
  favIcon: logo_namespaceObject,
  getAllowedPrefixes: function () {
    var _getAllowedPrefixes = config_asyncToGenerator( /*#__PURE__*/config_regeneratorRuntime().mark(function _callee() {
      var response, prefixes;
      return config_regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return fetch('https://api.labs.kadaster.nl/datasets/GeoData-Wizard/vocabulaires/prefixes');
          case 2:
            response = _context.sent;
            if (!response.ok) {
              _context.next = 10;
              break;
            }
            _context.next = 6;
            return response.json();
          case 6:
            prefixes = _context.sent;
            return _context.abrupt("return", prefixes);
          case 10:
            throw new Error("Failed to fetch prefixes, status code: ".concat(response.status));
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function getAllowedPrefixes() {
      return _getAllowedPrefixes.apply(this, arguments);
    }
    return getAllowedPrefixes;
  }(),
  homepageMarkdown: landing,
  icon: logo_namespaceObject,
  newDatasetAccessLevel: 'public',
  predicateConfig: {
    method: 'elastic',
    endpoint: elasticsearchEndpoint
  },
  primaryColor: '#00387d',
  publishOrder: ['download', 'triplyDB'],
  secondaryColor: '#008296',
  triplyDbInstances: [{
    label: 'PLDN',
    link: 'https://data.pldn.nl'
  }, {
    label: 'Kadaster',
    link: 'https://data.labs.kadaster.nl'
  }]
};
/* harmony default export */ const config = (globalThis.wizardConfig = wizardConfig);
})();

/******/ })()
;